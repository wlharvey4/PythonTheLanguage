# -*- mode: org; fill-column: 79 -*-

#+title: Python the Language
#+subtitle: Version {{{version}}} {{{time(%F %R)}}}
#+author: WLHarvey4
#+date:2019-07-04 11:25
#+macro: version 0.4.6

#+name:import-hello-and-this
#+header: :results output :exports results
#+begin_src python
import __hello__
import this
#+end_src

* Keywords
- False
- None
- True
- and
- as
- assert
- async
- await
- break
- class
- continue
- def
- del
- elif
- else
- except
- finally
- for
- from
- global
- if
- import
- in
- is
- lambda
- nonlocal
- not
- or
- pass
- raise
- return
- try
- while
- with
- yield

* Operators
  Operators are the constructs which can manipulate the value of operands.

  Python language supports the following types of operators.

** Arithmetic
   - unary operators :: ~+~ (unchanged), ~-~ (negation), =~= (bitwise
        inversion)
   - addition (+) :: Adds values on either side of the operator.
   - subtraction (-) :: Subtracts right hand operand from left hand operand.
   - multiplication (*) :: Multiplies values on either side of the operator
        + The arguments must either both be numbers, or one argument must be an
          integer and the other must be a sequence.
        + In the former case, the numbers are converted to a common type and then
          multiplied together.
        + In the latter case, sequence repetition is performed; a negative
          repetition factor yields an empty sequence.
   - division (/) :: Divides left hand operand by right hand operand
   - modulus (%) :: Divides left hand operand by right hand operand and returns
                    remainder
   - power (**) :: Performs exponential (power) calculation on operators
                   + The power operator binds more tightly than unary operators on its left;
                     it binds less tightly than unary operators on its right.
                   + Thus, in an unparenthesized sequence of power and unary operators, the
                     operators are evaluated from right to left.
                   + The power operator has the same semantics as the built-in ~pow()~
                     function, when called with two arguments: it yields its left argument
                     raised to the power of its right argument. The numeric arguments are
                     first converted to a common type, and the result is of that type.
                   + For ~int~ operands, the result has the same type as the operands unless
                     the second argument is negative; in that case, all arguments are
                     converted to ~float~ and a ~float~ result is delivered.
                     : 10**2 := 100
                     : 10**-2 := 0.01
                   + Raising ~0.0~ to a negative power results in a ~ZeroDivisionError~.
                   + Raising a negative number to a fractional power results in a ~complex~
                     number.
   - floor division (//) :: Floor Division - The division of operands
        where the result is the quotient in which the digits after the
        decimal point are removed. But if one of the operands is
        negative, the result is floored, i.e., rounded away from zero
        (towards negative infinity)


   - The floor division and modulo operators are connected by the following
     identity: =x == (x//y)*y + (x%y)=
   - Floor division and modulo are also connected with the built-in function
     ~divmod()~: =divmod(x, y) == (x//y, x%y)=.

** Comparison (Relational)
   Objects have a value (in addition to type and identity).  The value of an
   object is a rather abstract notion in Python.  These operators /compare/ the
   values on either sides of them and decide the /relation/ among them.
   Comparison operators implement a particular notion of what the value of an
   object is. One can think of them as defining the value of an object indirectly,
   by means of their comparison implementation.  Comparisons yield boolean values:
   ~True~ or ~False~.

   - == :: If the values of two operands are equal, then the condition becomes
           true.
   - != :: If values of two operands are not equal, then condition becomes
           true.
   - <> :: If values of two operands are not equal, then condition becomes
           true.
   - > :: If the value of left operand is greater than the value of
          right operand, then condition becomes true.
   - < :: If the value of left operand is less than the value of right
          operand, then condition becomes true.
   - >= :: If the value of left operand is greater than or equal to
           the value of right operand, then condition becomes true.
   - <= :: If the value of left operand is less than or equal to the
           value of right operand, then condition becomes true.

   Because all types are (direct or indirect) subtypes of object, they inherit the
   default comparison behavior from object.  Types can customize their comparison
   behavior by implementing rich comparison methods like ~__lt__()~.

   The default behavior for equality comparison (~==~ and ~!=~) is based on the
   identity of the objects. Hence, equality comparison of instances with the same
   identity results in equality, and equality comparison of instances with
   different identities results in inequality. A motivation for this default
   behavior is the desire that all objects should be reflexive.

   A default order comparison (~<~, ~>~, ~<=~, and ~>=~) is not provided; an
   attempt raises ~TypeError~.  A motivation for this default behavior is the lack
   of a similar invariant as for equality.

   Comparisons can be /chained/ arbitrarily, e.g., ~x < y <= z~ is equivalent to
   ~x < y and y <= z~, except that ~y~ is evaluated only once (but in both cases
   ~z~ is not evaluated at all when ~x < y~ is found to be false).

*** Comparison Behavior of some Built-in Types
    - Numeric Types (~int~, ~float~, ~complex~) :: can be compared within and
         across their types, with the restriction that complex numbers do not
         support order comparison.
    - ~NaN~ Values :: Any ordered comparison of a number to a not-a-number value
                      is false.  Not-a-number values are not equal to themselves.
    - Binary sequences (~bytes~, ~bytearray~) :: can be compared within and
         across their types. They compare lexicographically using the numeric
         values of their elements.
    - Strings (~str~) :: compare lexicographically using the numerical Unicode
         code points (the result of the built-in function ~ord()~) of their
         characters.  Strings and binary sequences cannot be directly compared.
    - Sequences (~tuple~, ~list~, ~range~) :: can be compared only within each
         of their types, with the restriction that ranges do not support order
         comparison.  Equality comparison across these types results in
         inequality, and ordering comparison across these types raises
         ~TypeError~.  Sequences compare lexicographically using comparison of
         corresponding elements, whereby reflexivity of the elements is
         enforced.  Element identity is compared first, and element comparison
         is performed only for distinct elements.  Lexicographical comparison
         between built-in collections works as follows:
         + For two collections to compare equal, they must be of the same type,
           have the same length, and each pair of corresponding elements must
           compare equal
         + Collections that support order comparison are ordered the same as their
           first unequal elements.  If a corresponding element does not exist, the
           shorter collection is ordered first.
    - Mappings (~dict~) :: compare equal if and only if they have equal (key,
         value) pairs. Equality comparison of the keys and values enforces
         reflexivity.  Order comparisons (~<~, ~>~, ~<=~, and ~>=~) raise
         ~TypeError~.
    - Sets (~set~, ~frozenset~) :: can be compared within and across their
         types.  They define order comparison operators to mean subset and
         superset tests. Those relations do not define total orderings.  Sets
         are not appropriate arguments for functions which depend on total
         ordering (for example, ~min()~, ~max()~, and ~sorted()~ produce
         undefined results given a list of sets as inputs).
    - Other :: Most other built-in types have no comparison methods
               implemented, so they inherit the default comparison behavior.

*** User-Defined Classes
    User-defined classes that customize their comparison behavior should follow
    some consistency rules:
    - Equality comparison should be reflexive. In other words, identical
      objects should compare equal
    - Comparison should be symmetric.
    - Comparison should be transitive.
    - Inverse comparison should result in the boolean negation.
    - The ~hash()~ result should be consistent with equality. Objects that are
      equal should either have the same hash value, or be marked as unhashable.
** Assignment
   - = :: Assigns values from right side operands to left side operand
   - += Add AND :: It adds right operand to the left operand and
                   assign the result to left operand
   - -= Subtract AND :: It subtracts right operand from the left
        operand and assign the result to left operand
   - *= Multiply AND :: It multiplies right operand with the left
        operand and assign the result to left operand
   - /= Divide AND :: It divides left operand with the right operand
                      and assign the result to left operand
   - %= Modulus AND :: It takes modulus using two operands and assign
                       the result to left operand
   - **= Exponent AND :: Performs exponential (power) calculation on
        operators and assign value to the left operand
   - //= Floor AND :: It performs floor division on operators and
                      assign value to the left operand

** Boolean (Logical)
   - and :: If both the operands are true then condition becomes true.  The
            expression ~x and y~ first evaluates ~x~; if ~x~ is false, its
            value is returned; otherwise, ~y~ is evaluated and the resulting
            value is returned.
   - or :: If any of the two operands are non-zero then condition becomes true.
           The expression ~x or y~ first evaluates ~x~; if ~x~ is true, its
           value is returned; otherwise, ~y~ is evaluated and the resulting
           value is returned.
   - not :: Used to reverse the logical state of its operand.

   Note that neither ~and~ nor ~or~ restrict the value and type they return to
   ~False~ and ~True~, but rather return the last evaluated argument.  If ~s~ is a
   string that should be replaced by a default value if it is empty, the
   expression ~s or 'foo'~ yields the desired value.

   The operator ~not~ yields ~True~ if its argument is false, ~False~ otherwise.
   Because ~not~ has to create a new value, it returns a boolean value regardless
   of the type of its argument (for example, ~not 'foo'~ produces ~False~ rather
   than ''.)

   In the context of Boolean operations, and also when expressions are used by
   control flow statements, the following values are interpreted as ~False~:
   - ~False~,
   - ~None~,
   - numeric zero of all types, and
   - empty strings and containers (including strings, tuples, lists,
     dictionaries, sets and frozensets).

   All other values are interpreted as ~True~.

   User-defined objects can customize their truth value by providing a
   ~__bool__()~ method.

** Bitwise
   - & :: AND Operator copies a bit to the result if it exists in both
          operands
   - | :: OR Operator copies a bit if it exists in either operand.
   - ^ :: XOR Operator copies the bit if it is set in one operand but
          not both.
   - ~ :: Ones Complement s unary and has the effect of 'flipping'
          bits.
   - << :: Binary Left Shift; The left operands value is moved left by
           the number of bits specified by the right operand.
   - >> :: Binary Right Shift; The left operands value is moved right
           by the number of bits specified by the right operand.

** Membership
   Python’s membership operators test for membership in a sequence, such as
   strings, lists, or tuples.  ~x in s~ evaluates to ~True~ if ~x~ is a /member/
   of ~s~, and ~False~ otherwise.  ~x not in s~ returns the negation of ~x in s~.
   - in :: Evaluates to true if it finds a variable in the specified
           sequence and false otherwise.
   - not in :: Evaluates to true if it does not finds a variable in
               the specified sequence and false otherwise.

   All built-in sequences and set types support this as well as dictionary, for
   which in tests whether the dictionary has a given key.

   For container types such as ~list~, ~tuple~, ~set~, ~frozenset~, ~dict~, or
   ~collections.deque~, the expression ~x in y~ is equivalent to ~any(x is e or x
   == e for e in y)~.

   For the string and bytes types, ~x in y~ is ~True~ if and only if ~x~ is a substring
   of ~y~.

   For user-defined classes which define the ~__contains__()~ method, ~x in y~
   returns ~True~ if ~y.__contains__(x)~ returns a true value, and ~False~
   otherwise.

   For user-defined classes which do not define ~__contains__()~ but do define
   ~__iter__()~, ~x in y~ is ~True~ if some value ~z~ with ~x == z~ is produced while
   iterating over ~y~.  If an exception is raised during the iteration, it is as if
   ~in~ raised that exception.

   Lastly, the old-style iteration protocol is tried: if a class defines
   ~__getitem__()~, ~x in y~ is ~True~ if and only if there is a non-negative
   integer index ~i~ such that ~x == y[i]~, and all lower integer indices do not
   raise ~IndexError~ exception.

   The operator ~not in~ is defined to have the inverse true value of ~in~.

   #+NAME: membership
   #+BEGIN_SRC python -n :results output :tangle membership.py :exports both :eval no-export

  a = 10
  b = 20
  list = [1, 2, 3, 4, 5 ];

  if ( a in list ):
     print ("Line 1 - a is available in the given list")
  else:
     print ("Line 1 - a is not available in the given list")

  if ( b not in list ):
     print ("Line 2 - b is not available in the given list")
  else:
     print ("Line 2 - b is available in the given list")

  a = 2
  if ( a in list ):
     print ("Line 3 - a is available in the given list")
  else:
     print ("Line 3 - a is not available in the given list")

   #+END_SRC

   #+RESULTS: membership
   : Line 1 - a is not available in the given list
   : Line 2 - b is not available in the given list
   : Line 3 - a is available in the given list
   : done

** Identity
   The operators ~is~ and ~is not~ test for object identity.  Object identity is
   determined using the ~id()~ function.

   Identity operators compare the memory locations of two objects.
   - is :: Evaluates to true if the variables on either side of the
           operator point to the same object and false otherwise.

           ~x is y~, here ~is~ results in 1 if ~id(x)~ equals ~id(y)~.

   - is not :: Evaluates to false if the variables on either side of
               the operator point to the same object and true
               otherwise.

               ~x is not y~, here ~is not~ results in 1 if ~id(x)~ is
               not equal to ~id(y)~.

   #+NAME: identity
   #+BEGIN_SRC python -n :results output :exports both :tangle identity.py :eval no-export

#!/usr/bin/python3

a = 20
b = 20

if ( a is b ):
   print ("Line 1 - a and b have same identity")
else:
   print ("Line 1 - a and b do not have same identity")

if ( id(a) == id(b) ):
   print ("Line 2 - a and b have same identity")
else:
   print ("Line 2 - a and b do not have same identity")

b = 30
if ( a is b ):
   print ("Line 3 - a and b have same identity")
else:
   print ("Line 3 - a and b do not have same identity")

if ( a is not b ):
   print ("Line 4 - a and b do not have same identity")
else:
   print ("Line 4 - a and b have same identity")

   #+END_SRC

   #+RESULTS:
   : Line 1 - a and b have same identity
   : Line 2 - a and b have same identity
   : Line 3 - a and b do not have same identity
   : Line 4 - a and b do not have same identity

** Precedence
   1. ~**~ Exponentiation
   2. ~~ + -~ Complement, unary plus and minus (method names for the last
      two are +@ and -@)
   3. ~* / % //~ Multiply, divide, modulo and floor division
   4. ~+ -~ Addition and subtraction
   5. ~>> <<~ Right and left bitwise shift
   6. ~&~ Bitwise 'And'
   7. ~^ |~ Bitwise exclusive `OR' and regular `OR'
   8. ~<= < > >=~ Comparison operators
   9. ~<> == !=~ Equality operators
   10. ~= %= /= //= -= += *= **=~ Assignment operators
   11. ~is is not~ Identity operators
   12. ~in not in~ Membership operators
   13. ~not or and~ Logical operators


   The following table summarizes the operator precedence in Python, from
   lowest precedence (least binding) to highest precedence (most
   binding). Operators in the same box have the same precedence. Unless the
   syntax is explicitly given, operators are binary. Operators in the same box
   group left to right (except for exponentiation, which groups from right to
   left).
   #+ATTR_TEXINFO: :columns .5 .5
   #+NAME: tab:precedence
   #+CAPTION: Operator Precedence
   | Operator                                                              | Description                                                                |
   |-----------------------------------------------------------------------+----------------------------------------------------------------------------|
   | lambda                                                                | Lambda expression                                                          |
   | ~if - else~                                                           | Conditional expression                                                     |
   | ~or~                                                                  | Boolean OR                                                                 |
   | ~and~                                                                 | Boolean AND                                                                |
   | ~not~                                                                 | Boolean NOT                                                                |
   | ~in~, ~not in~, ~is~, ~is not~, ~<~, ~<=~, ~>~, ~>=~, ~!=~, ~==~      | Comparisons, including membership tests and identity tests                 |
   | \vbar                                                                 | Bitwise OR                                                                 |
   | ~^~                                                                   | Bitwise XOR                                                                |
   | ~&~                                                                   | Bitwise AND                                                                |
   | ~<< >>~                                                               | Shifts                                                                     |
   | ~+ -~                                                                 | Addition and Subtraction                                                   |
   | ~*, @, /, //, %~                                                      | Multiplication, matrix multiplication, division, floor division, remainder |
   | ~+x, -x, ~x~                                                          | Positive, negative, bitwise NOT                                            |
   | ~**~                                                                  | Exponentiation                                                             |
   | ~await x~                                                             | Await expression                                                           |
   | ~x[index], x[index:index], x(arguments...), x.attribute~              | Subscription, slicing, call, attribute reference                           |
   | (expressions...), [expressions...], {key: value...}, {expressions...} | Binding or tuple display, list display, dictionary display, set display    |
   |-----------------------------------------------------------------------+----------------------------------------------------------------------------|

* Delimiters
  - ~( )~
  - ~[ ]~
  - ~{ }~
  - ~'~
  - ~: . ;~
  - ~@~
  - ~=~
  - ~->~
  - ~+= -= *= /= //= %= @= &= |= ^= >>= **=~

  The augmented assignment operators serve lexically as delimiters, but also
  perform an operation.

  ~' " # \~ have special meaning in Python.

  ~$ ? `~ are not used and their use outside of a string constitutes an error.
* Built-in Functions

#+cindex:built-in functions
- https://docs.python.org/3.7/library/functions.html#int

The Python interpreter has a number of functions and types built into it that
are always available.  They are listed here in alphabetical order.

- abs()

- all()

- any()

- ascii()

- bin()

- bool()

- breakpoint()

- bytearray()

- bytes()

- callable()

- chr()

- classmethod()

- compile()

- complex()

- delattr()

- dict()

- dir()

- divmod()

- enumerate()

- eval()

- exec()

- filter()

- float()

- format()

- frozenset()

- getattr()

- globals()

- hasattr()

- hash()

- help()

- hex()

- id()

- input()

- int()

  Return an integer object constructed from a number or string x, or return 0
  if no arguments are given.

  If x defines =__int__()=, ~int(x)~ returns =x.__int__()=.  If x defines =__trunc__()=, it
  returns =x.__trunc__()=.  For floating point numbers, this truncates towards
  zero.

  If x is not a number or if base is given, then x must be a string, =bytes=, or
  =bytearray= instance representing an integer literal in radix base.

- isinstance()

- issubclass()

- iter()

- len()

- list()

- locals()

- map()

- max()

- memoryview()

- min()

- next()

- object()

- oct()

- open()

- ord()

- pow()

- print()

- property()

- range()

- repr()

- reversed()

- rount()

- set()

- setattr()

- slice()

- sorted()

- staticmethod()

- str()

- sum()

- super()

- tuple()

- type()

- vars()

- zip()

- =__import__()=

* Data
** Data Model
   :CI:
   #+CINDEX: data model
   #+CINDEX: objects as data
   :END:
*** Objects --- Identity • Type • Value
    #+cindex:object, data model
    /Objects/ are Python’s  abstraction for *data*.  All data  in a Python
    program is represented by objects or by relations between objects.
    Every object has an:

    #+cindex:object attributes
    #+cindex:identity, data model
    - identity :: immutable; an object's place in memory
                  #+cindex:@code{is} operator
                  - ~is~ :: operator to compare the identity of two objects
                  #+cindex:@code{id} function
                  #+cindex:CPhython, @code{id} function
                  - ~id()~  :: function that returns an integer representing
                               the object's identity.  For CPython, ~id(x)~ is
                               the memory address where ~x~ is stored.

    #+cindex:type, data model
    - type :: determines the operations that the object supports, and the
              possible values for objects of that type.
              #+cindex:@code{type} function
              - ~type()~ :: function returns an object's type (an object itself);
                            type is immutable

    #+cindex:value, data model
    #+cindex:mutability, data model
    #+cindex:mutable objects
    #+cindex:immutable objects
    - value :: values can be either mutable or immutable, which is
               determined by its type.  Numbers, strings, and tuples are
               /immutable/, while dictionaries and lists are /mutable/.

    #+cindex:garbage collection
    #+cindex:CPython, garbage collection
    Objects are nevery explicitly destroyed; rather, they are garbage-collected
    when they become unreachable.  CPython currently uses a reference-counting
    scheme with (optional) delayed detection of cyclically linked garbage,
    which collects most objects as soon as they become unreachable, but is not
    guaranteed to collect garbage containing circular references.

*** Container Objects
    #+cindex:container objects, data model
    #+cindex:containers
    #+cindex:references, to objects
    /Container objects/ are objects that contain references to other
    objects.  Examples are:
    - tuples
    - lists
    - dictionaries

    #+cindex:mutability, containers
    #+cindex:container value, reference
    The references are part of a container’s value.  When referring to the
    /mutability/ of a container, the identities of the immediately
    contained objects are implied.  Thus, if an immutable container (like
    a tuple) contains a reference to a mutable object, its value changes
    if that mutable object is changed.

** Type Hierarchy
#+cindex:types, built-in
#+cindex:standard types
A discussion of the standard types built into Python.  Extension modules
(written in C, Java, or other languages, depending on the implementation) can
define additional types.

#+cindex:special attributes
#+cindex:attributes, special
- Special attributes ::

     These are attributes that provide access to the implementation and are not
     intended for general use.  Their definition may change in the future.

*** None
    #+cindex:@code{None}, type
    #+cindex:@code{false}, @code{None}
    - ~None~ :: single object with a single value, accessed through the
                name ~None~.  It signifies /the absence of a value/,
                i.e., it would be returned from a function that did not
                explicitly return anything.  It's *truth* value is
                /false/.

*** NotImplemented
    #+cindex:@code{NotImplemented}, type
    #+cindex:@code{true}, @code{NotImplemented}
    - ~NotImplemented~ :: single object with a single value, accessed
         through the name ~NotImplemented~.  Numeric methods and rich
         comparison methods should return this value if they do not
         implement the operation for the operands provided.  It's *truth*
         value is /true/.

*** Ellipsis
    #+cindex:@code{Ellipsis}, type
    #+cindex:@code{...}, @code{Ellipsis}
    #+cindex:@code{true}, @code{Ellipsis}
    - ~Ellipsis~ :: single object with a single value, accessed through the
                    literal =...= or the name ~Ellipsis~.  It's *truth* value
                    is /true/.

*** numbers.Number
    #+cindex:@code{numbers.Number}, type
    #+cindex:@code{Number}, type
    These types are created by numeric literals and returned as results by
    arithmetic operators and arithmetic built-in functions.  They are
    immutable.  Python distinguishes between integers, floating point
    numbers, and complex numbers.

**** ~numbers.Integral~
     #+cindex:@code{numbers.Integral}, type
     #+cindex:@code{Integral}, type
     #+cindex:integers
     These are integers.  There are two types:

***** Integers ~int~
      #+cindex:@code{int}, type
      These represent numbers in an unlimited range, subject to available
      (virtual) memory only.

***** Booleans ~bool~
     #+cindex:@code{bool}, type
     #+cindex:Booleans
     #+cindex:@code{False}
     #+cindex:@code{True}
      These represent the truth values ~False~ and ~True~.  The Boolean type is a
      subtype of the integer type, and Boolean values behave like the values 0 and 1,
      respectively, in almost all contexts, the exception being that when converted
      to a string, the strings "False" or "True" are returned, respectively.

**** ~numbers.Real~ • Float
     #+cindex:@code{Real}, type
     #+cindex:@code{Float}, type
     #+cindex:floating point numbers, double precision
     #+cindex:double precision
     #+cindex:single precision
     These represent machine-level double precision floating point numbers.  Python
     does not support single-precision floating point numbers;

**** ~numbers.Complex~ • Complex
     #+cindex:@code{Complex}, type
     #+cindex:complex numbers
     #+cindex:double precision pair
     These represent complex numbers as a pair of machine-level double
     precision floating point numbers.  The real and imaginary parts of a
     complex number ~z~ can be retrieved through the read-only attributes:
     #+cindex:@code{z.real} attribute
     #+cindex:@code{z.imag} attribute
     - ~z.real~
     - ~z.imag~

*** Sequences
    :CI:
    #+CINDEX: select, sequence
    #+CINDEX: slice, sequence
    #+CINDEX: slice, extended, sequence
    :END:
    #+cindex:sets, sequences
    Sequences represent finite ordered sets indexed by non-negative numbers.

    #+CINDEX:@code{len()} function, sequences
    - ~len()~ :: function that returns the number of items of a sequence (zero
                 indexed).
    - selecting :: ~a[i]~ selects item ~i~ of sequence ~a~
    - slicing :: ~a[i:j]~ selects all items with index k such that ~i <= k < j~.
    - extended slicing :: ~a[i:j:k]~ selects all items of ~a~ with index ~x~ where
         ~x = i + n*k~, ~n >= 0~ and ~i <= x < j~.


    #+cindex:mutability, sequences
    Sequences are distingushed according to their mutability.

**** Immutable Sequences
#+cindex:immutable sequences
#+cindex:sequences, immutable
An object of an immutable sequence type cannot change once it is created.

***** Strings
#+cindex:@code{String}, type
#+cindex:immutable, String
#+cindex:Unicode code points, String
#+cindex:@code{char} type, none
A sequence of values that represent Unicode code points.  All the code points
in the range =U+0000 - U+10FFFF= can be represented in a string.  There is no
~char~ type (every code point in the string is represented as a string object
with length 1).

#+cindex:@code{ord()} function
- ~ord()~ :: converts a code point from its string form to an integer in
             the range =0 - 10FFFF=

#+cindex:@code{chr()} function
- ~chr()~ :: converts an integer in the range =0 - 10FFFF= to the
             corresponding length 1 string object.

#+cindex:@code{str.encode()} method
- ~str.encode()~ :: used to convert a ~str~ to ~bytes~ using the given
                    text encoding

#+cindex:@code{bytes.decode()} method
- ~bytes.decode()~ :: used to convert ~bytes~ to ~str~ using the given text
     encoding

***** Tuples
#+cindex:@code{Tuples} type
Tuples of two or more items are formed by comma-separated lists of
expressions.  The items of a tuple are arbitrary Python objects.  A tuple
of one item (a /singleton/) can be formed by affixing a comma to an
expression.  An empty tuple can be formed by an empty pair of
parentheses.

***** Bytes
#+cindex:@code{Bytes}, type
A ~bytes~ object is an immutable array.  The items are 8-bit bytes,
represented by integers in the range ~0 <= x < 256~.  To construct a
~bytes~ object, use:

- ~b'abc'~ :: ~bytes~ literal

#+cindex:@code{bytes()} constructor
- ~bytes()~ :: ~bytes~ constructor

#+cindex:@code{decode()} method
#+cindex:@code{bytes.decode()} method
- ~decode()~ :: method to convert a ~bytes~ object to a string

**** Mutable Sequences
#+cindex:mutable sequences
#+cindex:sequences, mutable
#+cindex:@code{array}, extension module
Mutable sequences can be changed after they are created.  There are two
built-in mutable sequence types.  The extension module ~array~ provides
an additional example of a mutable sequence type.

***** Lists
#+CINDEX:lists, mutable sequence
Lists are formed by placing a comma-separated list of expressions in square
brackets.  The items of a list are arbitrary Python objects.

***** Byte Arrays
#+cindex:@code{bytearray} type
A mutable array.  Provide the same interface and functionality as immutable
~bytes~ object.  Since a ~bytearray~ is mutable, it is also unhashable.

#+cindex:@code{bytearray()} constructor
- ~bytearray()~ :: constructor

***** Arrays
#+cindex:Arrays, extension module
#+cindex:@code{array} type
The ~array~ extension module provides efficient arrays of basic numeric values:

+ characters
+ integers
+ floating point numbers


Arrays are /sequence types/ and behave very much like lists, except that the
type of objects stored in them is constrained.  The type is specified at object
creation time by using a type code, which is a single character.

****** Sequence Operations
       Array objects support the ordinary sequence operations of
       + indexing
       + slicing
       + concatenation
       + multiplication
****** Buffer Interface
       Array objects also implement the buffer interface, and may be used
       wherever ~bytes~-like objects are supported.
****** Slice Assignment
       When using slice assignment, the assigned value must be an array object
       with the same type code; in all other cases, ~TypeError~ is raised.
****** Type Codes
       The following type codes are defined:

       | Type Code | C Type               | Python Type       | Min Size (bytes) | Notes  |
       |-----------+----------------------+-------------------+------------------+--------|
       | 'b'       | signed ~char~        | ~int~             |                1 |        |
       | 'B'       | unsigned ~char~      | ~int~             |                1 |        |
       | 'u'       | ~Py_UNICODE~         | Unicode character |                2 | [fn:1] |
       | 'h'       | signed ~short~       | ~int~             |                2 |        |
       | 'H'       | unsigned ~short~     | ~int~             |                2 |        |
       | 'i'       | signed ~int~         | ~int~             |                2 |        |
       | 'I'       | unsigned ~int~       | ~int~             |                2 |        |
       | 'l'       | signed ~long~        | ~int~             |                4 |        |
       | 'L'       | unsigned ~long~      | ~int~             |                4 |        |
       | 'q'       | signed ~long long~   | ~int~             |                8 | [fn:2] |
       | 'Q'       | unsigned ~long long~ | ~int~             |                8 | [fn:2] |
       | 'f'       | ~float~              | ~float~           |                4 |        |
       | 'd'       | ~double~             | ~float~           |                8 |        |
       |-----------+----------------------+-------------------+------------------+--------|
****** Standard Library Reference
       [[https://docs.python.org/3/library/array.html#module-array][array]]

[fn:1] The 'u' type code corresponds to Python’s obsolete unicode character
(~Py_UNICODE~ which is ~wchar_t~).  Depending on the platform, it can be 16 bits or
32 bits.  'u' will be removed together with the rest of the ~Py_UNICODE~ API in
4.0.
[fn:2] The 'q' and 'Q' type codes are available only if the platform C compiler
used to build Python supports C ~long long~, or, on Windows, ~__int64~.
****** Defined Array Types
       - class array.array(/typecode/[, /initializer/]) :: A new array whose
            items are restricted by /typecode/, and initialized from the
            optional /initializer/ value, which must be a list, a ~bytes~-like
            object, or iterable over elements of the appropriate type.  If
            given a list or string, the initializer is passed to the new
            array’s ~fromlist()~, ~frombytes()~, or ~fromunicode()~ method to
            add initial items to the array.
       - array.typecodes :: a string with all available type codes.

***** Collections Extension Module---Container Types
:PROPERTIES:
:source-code: [[https://github.com/python/cpython/blob/3.7/Lib/collections/__init__.py][Lib/collections/__init__.py]]
:END:
#+cindex:Collections
#+cindex:Container types
This module implements specialized container datatypes providing alternatives
to Python’s general purpose built-in containers, ~dict~, ~list~, ~set~, and
~tuple~.

See https://docs.python.org/3/library/collections.html#module-collections

****** namedtuple()

****** deque

****** ChainMap

****** Counter

****** OrderedDict

****** defaultdict

****** UserDict

****** UserList

****** UserString

*** Set Types
    :CI:
    #+CINDEX: sets
    #+CINDEX: frozen sets
    :END:
    Sets represent unordered, finite sets of unique, immutable objects.  They
    cannot be indexed by any subscript.  They can be iterated over.
    - ~len()~ :: returns the number of items in a set. 

    Common uses for sets are:
    - fast membership testing
    - removing duplicates from a sequence
    - computing mathematical operations such as intersection, union,
      difference, and symmetric difference

    There are currently two intrinsic set types:

**** Sets
     These represent a mutable set.
     - ~set()~ :: constructor

**** Frozen Sets
     These represent an immutable set.  They are hashable, and therefore can be
     used again as an element of another set, or as a dictionary key.
     - ~frozenset()~ :: constructor

*** Mappings
    Mappings represent finite sets of objects indexed by arbitrary index sets.

    - ~a[k]~ :: selects the item indexed by ~k~ from the mapping ~a~
    - ~len()~ :: returns the number of items in a mapping

    There is currently a single intrinsic mapping type:

**** Dictionaries
     Dictionaries represent finite sets of objects indexed by nearly arbitrary
     values.  The only types of values not acceptable as keys are values
     containing lists or dictionaries or other mutable types that are compared
     by value rather than by object identity because the efficient
     implementation of dictionaries requires a key’s hash value to remain
     constant.  They are mutable.
     - ~{ ... }~ :: dictionary constructor

     The [[https://docs.python.org/3/library/collections.html#module-collections][collections]] module provides additional mapping types.
*** Callable
    :CI:
    #+CINDEX: functions, user-defined, callable
    #+CINDEX: functions, built-in, callable
    #+CINDEX: functions, generator, callable
    #+CINDEX: functions, coroutine, callable
    #+CINDEX: methods, instance, callable
    #+CINDEX: methods, build-in, callable
    #+CINDEX: classes, callable
    #+CINDEX: instance, class, callable
    :END:
    These are the types to which the function call operation (see section
    Calls) can be applied.  (A call calls a callable object (e.g., a function)
    with a possibly empty series of arguments.)
**** User-defined functions
     A user-defined function object is created by a function definition.  It
     should be called with an argument list containing the same number of items
     as the function’s formal parameter list.
**** Instance methods
     An instance method object combines a class, a class instance and any
     callable object (normally a user-defined function).
**** Generator functions
     A /generator function/ is a function or method which uses the ~yield~
     statement.  Such a function, when called, always returns an iterator
     object which can be used to execute the body of the function:
     - calling the iterator’s ~iterator.__next__()~ method will cause the
       function to execute until it provides a value using the ~yield~ statement.
     - When the function executes a ~return~ statement or falls off the end, a
       ~StopIteration~ exception is raised and the iterator will have reached
       the end of the set of values to be returned.
**** Coroutine functions
     A /coroutine function/ is a function or method which is defined using
     ~async def~.  Such a function, when called, returns a ~coroutine~ object.
     - ~coroutine~ :: Coroutines is a more generalized form of
                      subroutines. Subroutines are entered at one point and
                      exited at another point. Coroutines can be entered,
                      exited, and resumed at many different points. They can
                      be implemented with the async def statement.
**** Asynchronous generator functions
     An /asynchronous generator function/ is function or method which is
     defined using ~async def~ and which uses the ~yield~ statement.  Such a
     function, when called, returns an ~asynchronous iterator object~ which can
     be used in an ~async for~ statement to execute the body of the function.
**** Built-in functions
     A built-in function object is a wrapper around a C function.  Examples of
     built-in functions are ~len()~ and ~math.sin()~.  The number and type of
     the arguments are determined by the C function.
**** Built-in methods
     This is really a different disguise of a built-in function, this time
     containing an object passed to the C function as an implicit extra
     argument.  An example of a built-in method is ~alist.append()~, assuming
     ~alist~ is a list object.
**** Classes
     Classes are callable.  These objects normally act as factories for new
     instances of themselves, but variations are possible for class types that
     override ~__new__()~.  The arguments of the call are passed to ~__new__()~
     and, in the typical case, to ~__init__()~ to initialize the new instance.
**** Class Instances
     Instances of arbitrary classes can be made callable by defining a
     ~__call__()~ method in their class.
*** Modules
    Modules are a basic organizational unit of Python code.
**** Creating Modules
     Modules are created using the:
     - import system :: invoked either by
                        * the ~import~ statement; or
                        * calling functions such as:
                          - ~importlib.import_module()~; and
                          - built-in ~__import__()~
**** Module Namespace
     A module object has a namespace implemented by a dictionary object
     + this is the dictionary referenced by the ~__globals__~ attribute of
       functions defined in the module
     + Attribute references are translated to lookups in this dictionary,
     + e.g., ~m.x~ is equivalent to ~m.__dict__["x"]~.
     + Attribute assignment updates the module’s namespace dictionary, e.g.,
       ~m.x = 1~ is equivalent to ~m.__dict__["x"] = 1~.
*** Custom Classes
    Custom class types are typically created by class definitions.  A class has
    a namespace implemented by a dictionary object.  Class attribute references
    are translated to lookups in this dictionary,
    + e.g., ~C.x~ is translated to ~C.__dict__["x"]~
    + When the attribute name is not found there, the attribute search
      continues in the base classes.

    When a class attribute reference (for class ~C~, say) would yield a class
    method object, it is transformed into an instance method object whose
    ~__self__~ attribute is ~C~.

    When it would yield a static method object, it is transformed into the
    object wrapped by the static method object.
*** Class Instance
    A class instance is created by calling a class object.  A class instance
    has a namespace implemented as a dictionary which is the first place in
    which attribute references are searched.  When an attribute is not found
    there, and the instance’s class has an attribute by that name, the search
    continues with the class attributes. If a class attribute is found that is
    a user-defined function object, it is transformed into an instance method
    object whose ~__self__~ attribute is the instance.  If no class attribute
    is found, and the object’s class has a ~__getattr__()~ method, that is
    called to satisfy the lookup.
*** I/O Objects
    A file object represents an open file.  Various shortcuts are available to
    create file objects:
    - ~open()~ built-in function
    - ~os.open()~
    - ~os.fdopen()~
    - ~makefile()~ method of socket objects

    The objects are initialized to file objects corresponding to the
    interpreter’s
    - ~sys.stdin~ --- standard input
    - ~sys.stdout~ --- standard output
    - ~sys.stderr~ --- standard error

    They are all open in text mode and therefore follow the interface defined
    by the ~io.TextIOBase~ abstract class.
*** Internal
    A few types used internally by the interpreter are exposed to the user.
**** Code objects
     Code objects represent byte-compiled executable Python code, or bytecode.
**** Frame objects
     Frame objects represent execution frames.
**** Traceback objects
     Traceback objects represent a stack trace of an exception.
**** Slice objects
     Slice objects are used to represent slices for ~__getitem__()~ methods.
     They are also created by the built-in ~slice()~ function.
**** Static method objects
     Static method objects provide a way of defeating the transformation of
     function objects to method objects described above.
**** Class method objects
     A class method object, like a static method object, is a wrapper around
     another object that alters the way in which that object is retrieved from
     classes and class instances.

** Iteration
*** Iterable
    #+cindex: iterable
    #+cindex: sequence types
    #+cindex: ~__iter()__~ method
    #+cindex: ~__getitem()__~ method
    #+cindex: Sequence semantics
    An {{{dfn(iterable)}}} is an object capable of returning its members one at
    a time. Examples of iterables include:
    - all sequence types (such as list, str, and tuple) and
    - some non-sequence types like dict, file objects, and
    - objects of any classes you define with an ~__iter__()~ method or
    - with a ~__getitem__()~ method that implements Sequence semantics.


    #+cindex: ~zip()~
    #+cindex: ~map()~
    Iterables can be used in a ~for~ loop and in many other places where a
    sequence is needed (~zip()~, ~map()~, …).

*** Iterator
    #+cindex: iterator
    #+cindex: iterable
    #+cindex: ~iter()~
    An {{{dfn(iterator)}}} is an object representing a stream of data.
    Repeated calls to the iterator’s ~__next__()~ method (or passing it to the
    built-in function ~next()~) return successive items in the stream.  When no
    more data are available a ~StopIteration~ exception is raised instead. At
    this point, the iterator object is exhausted and any further calls to its
    ~__next__()~ method just raise ~StopIteration~ again.

    Iterators are required to have an ~__iter__()~ method that returns the
    iterator object itself so every iterator is also iterable and may be used
    in most places where other iterables are accepted.

    When an iterable object is passed as an argument to the built-in function
    ~iter()~, it returns an /iterator/ for the object.  This iterator is good
    for one pass over the set of values.

*** Iterator Type
    #+cindex: iterator, iteration
    #+cindex: containers, iteration
    Python supports a concept of {{{dfn(iteration)}}} over containers. This is
    implemented using two distinct methods.  User-defined classes need to
    implement these two methods in order to support iteration.
    - ~container.__iter__()~ ::

         the method that needs to be defined for container objects to provide
         *iteration support*.  This method returns an iterator object.  This
         object is required to support the /iterator protocol/, defined by the
         following two methods.

    - ~iterator.__iter__()~ ::

         method that returns the iterator object.  This is required to allow
         both containers and iterators to be used with the ~for~ and ~in~
         statements.

    - ~iterator.__next__()~ ::

         method that returns the next item from the container, or raise the
         ~StopIteration~ exception if there are no further items.


    Python defines several iterator objects to support iteration over general
    and specific sequence types, dictionaries, and other more specialized
    forms. The specific types are not important beyond their implementation of
    the iterator protocol.  Once an iterator’s ~__next__()~ method raises
    ~StopIteration~, it must continue to do so on subsequent
    calls. Implementations that do not obey this property are deemed broken.

* Data Structures
- https://docs.python.org/3.7/tutorial/datastructures.html#list-comprehensions

** Lists
#+cindex:lists, data structures
#+cindex:list methods
*** Methods of list objects

#+cindex:@code{append()}
#+cindex:@code{list.append()}
- list.append(x)

  #+cindex:@code{extend()}
  #+cindex:@code{list.extend()}
- list.extend(iterable)

  #+cindex:@code{insert()}
  #+cindex:@code{list.insert()}
- list.insert(i, x)

  #+cindex:@code{remove()}
  #+cindex:@code{list.remove()}
- list.remove(x)

  #+cindex:@code{pop()}
  #+cindex:@code{list.pop()}
- list.pop([i])

  #+cindex:@code{clear()}
  #+cindex:@code{list.clear()}
- list.clear()

  #+cindex:@code{index()}
  #+cindex:@code{list.index()}
- list.index(x[, start[, end]])

  #+cindex:@code{count()}
  #+cindex:@code{list.count()}
- list.count(x)

  #+cindex:@code{sort()}
  #+cindex:@code{list.sort()}
- list.sort(key=None, reverse=False)

  #+cindex:@code{reverse()}
  #+cindex:@code{list.reverse()}
- list.reverse()

  #+cindex:@code{copy()}
  #+cindex:@code{list.copy()}
- list.copy()


#+cindex:list as stack
#+cindex:stack, using list
*** Lists as Stacks
#+cindex:stacks, from lists

#+cindex:LIFO
- Stack :: the last element added is the first element retrieved
           (“last-in,first-out” (LIFO)).

#+cindex:@code{append()}
#+cindex:stack, add
- Add to stack :: To add an item to the top of the stack, use ~append()~.

#+cindex:@code{pop()}
#+cindex:stack, retrieve
- Retrieve from stack :: To retrieve an item from the top of the stack, use
     ~pop()~ without an explicit index.

*** Lists as Queues
#+cindex:list as queue
#+cindex:queue, using list
#+cindex:FIFO
- Queue :: the first element added is the first element retrieved (“first-in,
           first-out” (FIFO)).  Lists are not efficient for this purpose.
           While appends and pops from the end of list are fast, doing inserts
           or pops from the beginning of a list is slow (because all of the
           other elements have to be shifted by one).

#+cindex:collections.deque
#+cindex:deque
#+cindex:queue
- ~collections.deque~ :: To implement a queue, use [[https://docs.python.org/3.7/library/collections.html#collections.deque][collections.deque]] which was
     designed to have fast appends and pops from both ends.


#+begin_src python
  from collections import deque

  queue = deque(["Eric", "John", "Michael"])
  queue.append("Terry")           # Terry arrives
  queue.append("Graham")          # Graham arrives
  queue.popleft()                 # The first to arrive now leaves
  #=> 'Eric'
  queue.popleft()                 # The second to arrive now leaves
  #=> 'John'

  queue                           # Remaining queue in order of arrival
  #=> deque(['Michael', 'Terry', 'Graham'])
#+end_src

*** List Comprehensions
#+cindex:list comprehensions
#+cindex:comprehensions, list
List comprehensions provide a concise way to create lists.  Common applications
are to make new lists where each element is the result of some operations
applied to each member of another sequence or iterable, or to create a
subsequence of those elements that satisfy a certain condition.

For example, assume we want to create a list of squares.  We can calculate the
list of squares without any side effects using:

#+begin_src python
squares = list(map(lambda x: x**2, range(10)))
#+end_src

or, equivalently:

#+begin_src python
squares = [x**2 for x in range(10)]
#+end_src

A /list comprehension/ consists of brackets containing an expression followed
by a ~for~ clause, then zero or more ~for~ or ~if~ clauses.  The result will be
a new list resulting from evaluating the expression in the context of the ~for~
and ~if~ clauses which follow it.

#+begin_src python
[(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]
#+end_src

List comprehensions can contain complex expressions and nested functions.

The initial expression in a list comprehension can be any arbitrary expression,
including another list comprehension.

*** Destructuring Collections
- [[https://blog.tecladocode.com/destructuring-in-python/][Destructuring Python]]


#+cindex:destructuring
#+cindex:unpacking
#+cindex:destructuring assignments
#+cindex:collections, destructuring
Destructuring (also called unpacking) is where we take a collection, like a
list or a tuple, and we break it up into individual values.  This is quite
useful, as it enables us to do things like destructuring assignments, where we
assign values to several variables at once from a single collection.

**** Destructuring Assignments
Python allows more than one variable assignment at a time; you must provide the
same number of values as variables (the values are assigned entirely based on
order).

: x, y = 5, 11

This is an example of destructuring.

: x, y = (5, 11)

#+cindex:tuples
Parentheses have nothing at all to do with tuples; rather, it's the commas
which tell Python something is a tuple.  Brackets are used for readability or
disambiguation.  Even here, brackets are still not part of the tuple syntax.
Therefore, the two examples above are semantically identical, the destructuring
of a tuple.

#+cindex:@code{ValueError}
Attempting to destructure a collection with the wrong number of variables
results in a ~ValueError~, e.g.:

: ValueError: not enough values to unpack (expected 4, got 3)

**** Destructuring in ~for~ Loops
#+cindex:@code{enumerate} function
#+cindex:@code{enumerate} object
#+cindex:iterable collection
#+cindex:tuple
The ~enumerate~ function takes an iterable collection as an argument and
returns an ~enumerate~ object containing a tuple for each item in the
collection.  Each tuple contains a counter value, which increments with each
iteration, along with a value from the provided collection.

#+cindex:@code{enumerate} syntax
The syntax for ~enumerate~ looks like this:

#+name:enumerate-syntax
#+header: :results output
#+begin_src python
example_list = ["A", "B", "C"]

for counter, letter in enumerate(example_list):
	print(counter, letter)
#+end_src

#+RESULTS: enumerate-syntax
: (0, 'A')
: (1, 'B')
: (2, 'C')

#+cindex:destructuring example
This is an example of destructuring: For each tuple in the ~enumerate~ object,
the first value gets assigned to ~counter~, and the second value is assigned to
~letter~.  It's possible to do this type of destructuring with as many values
as we like, and this is not limited to the ~enumerate~ function.

#+name:complex-destructuring
#+header: :results output
#+begin_src python
people = [
	("Bob", 42, "Mechanic"),
	("James", 24, "Artist"),
	("Harry", 32, "Lecturer")
]

for name, age, profession in people:
	print(f"Name: {name}, Age: {age}, Profession: {profession}")
#+end_src

#+RESULTS: complex-destructuring
: Name: Bob, Age: 42, Profession: Mechanic
: Name: James, Age: 24, Profession: Artist
: Name: Harry, Age: 32, Profession: Lecturer

**** Ignoring Values
To ignore a value, use =_= in place of a variable.  For example, if we take one
of the tuples from the the people list above, and we only care about the name
and profession, we can do the following:

#+name:ignoring-values
#+header: :results output
#+begin_src python
person = ("Bob", 42, "Mechanic")
name, _, profession = person

print(name, profession)  # Bob Mechanic
#+end_src

#+RESULTS: ignoring-values
: Bob Mechanic

This would also work just as well inside a loop, and can also be used when we
don't care about any of the values. An example might be when using range to
ensure a set number of iterations.

#+begin_src python
for _ in range(10):
	<do something>
#+end_src

**** Using =*= to Collect Values
#+cindex:@code{*} operator
In some situations, we might want to isolate one or two values in a collection,
and then keep the other items together.  In Python, we can use the =*= operator
to collect leftover values when performing a destructuring assignment.  For
example, we might have a list of numbers, and we want to grab the first number,
and then assign the remaining numbers to a second variable:

#+begin_src python
head, *tail = [1, 2, 3, 4, 5]

print(head)  # 1
print(tail)  # [2, 3, 4, 5]
#+end_src

We can also do this the other way around, creating a new list with everything
but the last value, and assigning the last value to its own variable.

#+begin_src python
*head, tail = [1, 2, 3, 4, 5]

print(head)  # [1, 2, 3, 4]
print(tail)  # 5
#+end_src

We can can assign any number of variables, and then gather up the remainder.
We might grab the first and last items, and then gather up the middle, for
example:

#+begin_src python
head, *middle, tail = [1, 2, 3, 4, 5]

print(head)    # 1
print(middle)  # [2, 3, 4]
print(tail)    # 5
#+end_src

Alternatively, we might want to grab the first three items and then bundle up
the rest:

#+begin_src python
first, second, third, *rest = [1, 2, 3, 4, 5]
#+end_src

* Execution

** Program Structure
   :CI:
   #+CINDEX: program
   #+CINDEX: code block
   #+CINDEX: block of code
   #+CINDEX: execution frame
   :END:
*** Program
    - program :: is constructed from code blocks
*** Code Block
    - block :: is a piece of Python program text that is executed as a unit.
               + module
               + function body
               + class definition
               + command typed interactively
               + script file (a file given as standard input to the interpreter or
                 specified as a command line argument to the interpreter)
               + script command (a command specified on the interpreter command line
                 with the -c option)
               + The string argument passed to the built-in functions ~eval()~ and
                 ~exec()~ is a code block.
*** Execution Frame
    - execution frame :: where a code block is executed.  A frame contains some
         administrative information (used for debugging) and determines where
         and how execution continues after the code block’s execution has
         completed.

** Naming and Binding
   - name :: refers to an object; introduced by name binding operations.

*** Name Binding
    - formal parameters to functions
    - ~import~ statements
    - class and function definitions
    - targets that are identifiers if occurring in an assignmetn
    - ~for~ loop header
    - ~as~ after a ~with~ statement or ~except~ clause
    - ~from ... import *~ binds all names defined in the imported module,
      except those beginning with an underscore.
    - target occurring in a ~del~ statement is considered bound

**** Where Binding Occurs
     - where occurs :: Each assignment or import statement occurs within a
                       block defined by a class or function definition or at
                       the module level (the top-level code block).
     - local variable :: If a name is bound in a block, it is a local variable
                         of that block
     - ~nonlocal~ or ~global~ declaration :: unless declared as nonlocal or
          global
     - global variable :: If a name is bound at the module level, it is a
          global variable.
     - module level :: The variables of the module code block are local and
                       global.
     - free variable :: a variable used in a code block but not defined there

*** Name Resolution
    #+CINDEX:name, binding
    #+CINDEX:binding, name, operations
    #+CINDEX:declarations, none
    #+CINDEX:block, code
    #+CINDEX:code block
    Python lacks declarations and allows name binding operations to occur
    anywhere within a code block.

    #+CINDEX:name resolution rules
    #+CINDEX:resolution, name, rules
    Each occurrence of a name in the program text refers to the binding of that
    name established by the following /name resolution rules/.

    #+CINDEX:scope
    #+CINDEX:block
    - scope :: defines the visibility of a name within a block
               #+CINDEX:local variable
               #+CINDEX:variable, local
               + local variable :: If a local variable is defined in a block, its scope
                                   includes that block.  If the definition occurs in a
                                   function block, the scope extends to any blocks
                                   contained within the defining one, unless a contained
                                   block introduces a different binding for the name.
    #+CINDEX:resolution
    - resolution :: When a name is used in a code block, it is resolved using
                    the nearest enclosing scope.
    #+CINDEX:block environment
    #+CINDEX:environment, block
    - block environment :: The set of all such scopes visible to a code block
         is called the block’s environment.
    #+CINDEX:@code{NameError} exception
    #+CINDEX:exception, @code{NameError}
    - ~NameError~ Exception :: the exception raised when a name is not found at
         all.
    #+CINDEX:@code{UnboundLocalError} exception
    #+CINDEX:exception, @code{UnboundLocalError}
    - ~UnboundLocalError~ Exception :: the error raised when if the current
         scope is a function scope, and the name refers to a local variable
         that has not yet been bound to a value at the point where the name is
         used.  This is a subclass of ~NameError~ exception.

**** References to the Current Block
     If a name binding operation occurs anywhere within a code block, all uses
     of the name within the block are treated as references to the current
     block.  This can lead to errors when a name is used within a block before
     it is bound.  This rule is subtle.

     The /local variables/ of a code block can be determined by scanning the
     entire text of the block for name binding operations.

**** Global Variables
     - global statement :: If the ~global~ statement occurs within a block, all
          uses of the name specified in the statement refer to the binding of
          that name in the top-level namespace.  Names are resolved in the
          top-level namespace by searching the global namespace, i.e. the
          namespace of the module containing the code block, and the builtins
          namespace, the namespace of the module ~builtins~.  The global
          namespace is searched first.  If the name is not found there, the
          builtins namespace is searched.  The ~global~ statement must precede
          all uses of the name.  The ~global~ statement has the same scope as a
          name binding operation in the same block. If the nearest enclosing
          scope for a free variable contains a global statement, the free
          variable is treated as a global.
     - nonlocal statement :: The ~nonlocal~ statement causes corresponding names
          to refer to previously bound variables in the nearest enclosing
          function scope.  ~SyntaxError~ is raised at compile time if the given
          name does not exist in any enclosing function scope.


**** Module Namespace
     The namespace for a module is automatically created the first time a module
     is imported.

     - ~__main__~ :: The main module for a script is always called ~__main__~.

**** Class Definition Blocks • Arguments to exec and eval
     These are special in the context of name resolution.

     A class definition is an executable statement that may use and define
     names.  These references follow the normal rules for name resolution

     with an exception that /unbound local variables/ are looked up in the
     global namespace.

     The namespace of the class definition becomes the /attribute dictionary/
     of the class.

*** Builtins

*** Dynamic Feature Interaction

** Exceptions

* Syntax
  - Lexical analysis :: The lexical analyzer reads source code and creates a
       stream of tokens that are fed into the parser, which runs the program.
       This section describes how the lexical analyzer breaks a file's contents
       into tokens.

** Source Encoding---Unicode UTF-8
   :CI:
   #+CINDEX: Unicode
   #+CINDEX: source encoding
   #+CINDEX: UTF-8
   :END:
   The lexical analyzer reads source code as Unicode code points; the source
   encoding, by default, is UTF-8.  The source file can give an encoding
   declaration on the first or second line, as:
   : # -*- coding: <encoding-name> -*-
   which must be a comment line that matches the regular expression:
   : coding[=:]\s*([-\w.]+)
   If an encoding is declared, the encoding name must be recognized by Python.

** Lines

*** Logical Lines
    :CI:
    #+CINDEX: logical line
    :END:
    A Python program is divided into logical lines.  The end of logical line is
    represented by the token ~<NEWLINE>~.  A logical line is constructed from
    one or more physical lines by following the explicit or implicit line
    joining rules.

*** Physical Lines
    :CI:
    #+CINDEX: physical line
    :END:
    A physical line is a sequence of characters terminated by an end-of-line
    sequence---the Unix form using ASCII ~LF~ (linefeed), the Windows form
    using the ASCII sequence ~CR LF~ (return followed by linefeed), or the old
    Macintosh form using the ASCII ~CR~ (return) character---or end of input.

*** Explicit Line Joining Rules
    Two or more physical lines may be joined into logical lines using backslash
    characters (~\~), according to the following rule:

    When a physical line ends in a backslash that is not part of a string
    literal or comment, it is joined with the following forming a single
    logical line, deleting the backslash and the following end-of-line
    character.

*** Implicit Line Joining Rules
    Expressions in parentheses, square brackets or curly braces can be split
    over more than one physical line without using backslashes.  Implicitly
    continued lines can carry comments.  The indentation of the continuation
    lines is not important.  Blank continuation lines are allowed.

    #+BEGIN_EXPORT  texinfo
    @tex
    \bigskip\hrule height 1pt \relax\bigskip
    @end tex
    #+END_EXPORT
    -----
    #+BEGIN_EXAMPLE
    month_names = [`Januari', `Februari', `Maart',      # These are the
                   `April',   `Mei',      `Juni',       # Dutch names
                   `Juli',    `Augustus', `September',  # for the months
                   `Oktober', `November', `December']   # of the year
    #+END_EXAMPLE
    -----
    #+BEGIN_EXPORT texinfo
    @tex
    \bigskip\hrule height 1pt\relax\bigskip
    @end tex
    #+END_EXPORT

*** Blank Lines
    + A logical line that contains only spaces, tabs, formfeeds and possibly a
      comment, is ignored (i.e., no NEWLINE token is generated).
*** Comments
    A comment starts with a hash character (#) that is not part of a string
    literal, and ends at the end of the physical line.  A comment signifies the
    end of the logical line unless the implicit line joining rules are invoked.
    A line ending in a backslash cannot carry a comment.  A backslash does not
    continue a comment.
*** Indentation
    Leading whitespace (spaces and tabs) at the beginning of a logical line is
    used to compute the indentation level of the line, which in turn is used to
    determine the grouping of statements.
**** Tabs
     Tabs are replaced by spaces to produce groups of eight.  The total number
     of spaces preceding the first non-blank character then determines the
     line’s indentation.
**** TabError
     Indentation is rejected as inconsistent if a source file mixes tabs and
     spaces in a way that makes the meaning dependent on the worth of a tab in
     spaces; a ~TabError~ is raised in that case.
**** Formfeed
     A formfeed character may be present at the start of the line; it will be
     ignored for the indentation calculations above. Formfeed characters
     occurring elsewhere in the leading whitespace have an undefined effect
**** ~INDENT~ and ~DEDENT~ Tokens
     The indentation levels of consecutive lines are used to generate ~INDENT~
     and ~DEDENT~ tokens, using a stack, as follows.
***** Zero
      Before the first line of the file is read, a single zero is pushed on the
      stack; this will never be popped off again.
***** Numbers Pushed On
      The numbers pushed on the stack will always be strictly increasing from
      bottom to top.  At the beginning of each logical line, the line’s
      indentation level is compared to the top of the stack. If it is equal,
      nothing happens. If it is larger, it is pushed on the stack, and one
      ~INDENT~ token is generated.
***** Numbers Pushed Off
      If it is smaller, it must be one of the numbers occurring on the stack;
      all numbers on the stack that are larger are popped off, and for each
      number popped off a ~DEDENT~ token is generated.
***** End Of File
      At the end of the file, a ~DEDENT~ token is generated for each number
      remaining on the stack that is larger than zero.
** Tokens
   - ~NEWLINE~
   - ~INDENT~
   - ~DEDENT~
   - ~IDENTIFIERS~
   - ~KEYWORDS~
   - ~LITERALS~
   - ~OPERATORS~
   - ~DELIMITERS~
*** Identifiers
    Also referred to as /names/.

    Within the ASCII range (U+0001..U+007F), the valid characters for
    identifiers are the same as in Python 2.x: the uppercase and lowercase
    letters A through Z, the underscore _ and, except for the first character,
    the digits 0 through 9.

    Python 3.0 introduces additional characters from outside the ASCII range
    (see [[https://www.python.org/dev/peps/pep-3131][PEP 3131]]).

    Identifiers are unlimited in length. Case is significant.
*** Keywords
    Also referred to as /reserved words/.

    Reserved words cannot be used as ordinary identifiers.
*** Reserved Classes of Identifiers
    Certain classes of identifiers (besides keywords) have special
    meanings. These classes are identified by the patterns of leading and
    trailing underscore characters:

    - ~_*~ :: These identifiers are not imported by the statement ~from module
              import *~.
    - ~__*__~ :: System-defined names.  These names are defined by the
                 interpreter and its implementation (including the standard
                 library).  Current system names are discussed in the [[https://docs.python.org/3/reference/datamodel.html#specialnames][Special
                 method names]] section and elsewhere.
    - ~__*~ :: Class-private names.  Names in this category, when used within
               the context of a class definition, are re-written to use a
               mangled form to help avoid name clashes between “private”
               attributes of base and derived classes.
** Literals
   Literals are notations for constant values of some built-in types.
*** Bytes Literals
    Whitespace is not allowed between the bytesprefix and the rest of the
    literal.  They can be enclosed in matching single quotes (') or double
    quotes ("). They can also be enclosed in matching groups of three single or
    double quotes.  The backslash (\) character is used to escape characters
    that otherwise have a special meaning, such as newline, backslash itself,
    or the quote character.

    Bytes literals are always prefixed with 'b' or 'B'; they produce an
    instance of the ~bytes~ type instead of the ~str~ type. They may only
    contain ASCII characters; bytes with a numeric value of 128 or greater must
    be expressed with escapes.
*** String Literals
    Whitespace is not allowed between the stringprefix and the rest of the
    literal.  They can be enclosed in matching single quotes (') or double
    quotes ("). They can also be enclosed in matching groups of three single or
    double quotes.  The backslash (\) character is used to escape characters
    that otherwise have a special meaning, such as newline, backslash itself,
    or the quote character.
*** Raw Strings
    Both string and bytes literals may optionally be prefixed with a letter 'r'
    or 'R'; such strings are called /raw strings/ and treat backslashes as
    literal characters.  As a result, in string literals, '\U' and '\u' escapes
    in raw strings are not treated specially.

    *New in version 3.3:* The 'rb' prefix of raw bytes literals has been added
    as a synonym of 'br'.
*** Formatted String Literals
    A string literal with 'f' or 'F' in its prefix is a formatted string
    literal; the 'f' may be combined with 'r', but not with 'b' or 'u',
    therefore raw formatted strings are possible, but formatted bytes literals
    are not.

    In triple-quoted literals, unescaped newlines and quotes are allowed (and
    are retained), except that three unescaped quotes in a row terminate the
    literal.

    Unless an 'r' or 'R' prefix is present, escape sequences in string and
    bytes literals are interpreted according to rules similar to those used by
    Standard C.
    - ~\newline~ :: ignored
    - ~\\~ :: backslash
    - ~\'~ :: single quote
    - \"~ :: double quote
    - ~\a~ :: ~BEL~
    - ~\b~ :: ~BS~
    - ~\f~ :: ~FF~
    - ~\n~ :: ~LF~
    - ~\r~ :: ~CR~
    - ~\t~ :: ~TAB~
    - ~\v~ :: ~VT~
    - ~\ooo~ :: char with octal value ~ooo~
    - ~\xhh~ :: char with hex value ~hh~

    Escape sequences only recognized in string literals are:
    - ~\N{name}~ :: Character named name in the Unicode database
    - ~\uxxxx~ :: char with 16-bit hex value ~xxxx~
    - ~\Uxxxxxxxx~ :: char with 32-bit hex value ~xxxxxxxx~
*** Unrecognized Escape Sequences
    All unrecognized escape sequences are left in the string unchanged, i.e.,
    the backslash is left in the result. (This behavior is useful when
    debugging: if an escape sequence is mistyped, the resulting output is more
    easily recognized as broken.) It is also important to note that the escape
    sequences only recognized in string literals fall into the category of
    unrecognized escapes for bytes literals.

    *Changed in version 3.6*: Unrecognized escape sequences produce a
    ~DeprecationWarning~. In some future version of Python they will be a
    ~SyntaxError~.
*** Raw Strings and Backslashes
    Even in a raw literal, quotes can be escaped with a backslash, but the
    backslash remains in the result;

    A raw literal cannot end in a single backslash (since the backslash would
    escape the following quote character).

    Note also that a single backslash followed by a newline is interpreted as
    those two characters as part of the literal, not as a line continuation.
*** Numeric Literals
    There are three types of numeric literals: integers, floating point
    numbers, and imaginary numbers.  Complex numbers can be formed by adding a
    real number and an imaginary number.  Note that numeric literals do not
    include a sign.  To create a negative literal, use the unary operator ~-~.
*** Integer Literals
    Integer literals are:
    - decimal integer :: 123_456_789
    - binary integer :: 0b0101 | 0B0101
    - octal integer :: 0o123 | 0O123
    - hex integer :: 0x10af | 0X10AF

    There is no limit for the length of integer literals apart from what can be
    stored in available memory.  Underscores can be used to group digits for
    readability, and are ignored for determining value.
*** Floating Point Literals
    The integer and exponent parts are always interpreted using radix 10.  The
    allowed range of floating point literals is implementation-dependent.
    Underscores are supported for digit grouping.
*** Imaginary Literals
    An imaginary literal is a floating point literal followed by the letter
    ~j|J~.  An imaginary literal yields a complex number with a real part of
    0.0.  Complex numbers are represented as a pair of floating point numbers.
    To create a complex number with a nonzero real part, add a floating point
    number to it, e.g., (~3+4j~).
*** Ellipsis Literals
    ~...~ :: A sequence of three periods has a special meaning as an ellipsis
    literal.

* Import System
  :CI:
  #+CINDEX: import
  #+CINDEX: module
  #+CINDEX: package
  #+CINDEX: namespace
  #+CINDEX: @file{__PATH__} attribute
  :END:
  - module (informal) :: A file containing Python definitions and statements.
       The module name is the file name without the suffix ~.py~.  Within the
       module, the module's string name is available as the global variable
       ~__name__~.  The statement ~import <module>~ enters the module name the
       symbol table, and one can access the module's attributes using dot
       notation.
  - module (formal) :: An *object* that serves as an organizational unit of
       Python code.  Modules have a *namespace* containing arbitrary Python
       objects.  Modules are loaded into Python by the process of *importing*.
  - package :: A Python *module* which can contain submodules or recursively,
               subpackages.  Technically, a *package* is a Python *module* with
               an ~__path__~ attribute.


  One module gains access to code from another module by the process of
  /importing/ it.  There are several different mechanisms that can be used to
  import code.
  - ~import~ Statement :: combines a search for a named module using the
       ~__import__()~ function, then binds the results of that search, the
       return value of ~__import__()~, to a name in the local scope.
  - ~builtins.__import__()~ :: a direct call can be made to ~__import__()~,
       which will perform a search for a module; if a module is found, it
       creates the module.  No name-binding operation occurs, however.
  - ~importlib.import_module()~ :: may choose to bypass ~__import__()~ and use
       its own solutions to implement import semantics.


  :CI:
  #+CINDEX: module object
  #+CINDEX: @file{types.ModuleType()}
  #+CINDEX: hooks, import
  #+CINDEX: PEP 302
  #+CINDEX: PEP 420
  #+CINDEX: @file{sys.meta_path}
  #+CINDEX: namespace, package
  :END:
  - When a module is first imported, Python /searches/ for the module and if
    found, it /creates a module object/ (see ~types.ModuleType()~),
    initializing it.
  - If the named module cannot be found, a ~ModuleNotFoundError~ is raised.
  - Python implements various strategies to search for the named module when
    the import machinery is invoked.
  - These strategies can be modified and extended by using various /hooks/.
  - The import system has been updated to fully implement the second phase of
    [[https://www.python.org/dev/peps/pep-0302][PEP 302.]]
  - There is no longer any implicit import machinery - the full import system
    is exposed through [[https://docs.python.org/3/library/sys.html#sys.meta_path][sys.meta_path]].
  - In addition, native namespace package support has been implemented (see [[https://www.python.org/dev/peps/pep-0420][PEP
    420]]).


  :CI:
  #+CINDEX: @file{sys.meta_path}
  #+CINDEX: meta path finder object
  #+CINDEX: finder object
  #+CINDEX: loader object
  #+CINDEX: path entry finder object
  #+CINDEX: path entry hook
  :END:
  + ~sys.meta_path~ :: A list of /meta path finder/ objects that have their
       ~find_spec()~ methods called to see if one of the objects can find the
       module to be imported.
  + meta path finder object :: A /finder/ returned by a search of
       ~sys.meta_path~.  Meta path finders are related to, but different
       from [[https://docs.python.org/3/glossary.html#term-path-entry-finder][path entry finders]].
  + finder object :: An object that tries to find the /loader/ for a module
                     that is being imported.
  + loader :: An object that loads a module.  It must define a method named
              ~load_module()~.  See [[https://www.python.org/dev/peps/pep-0302][PEP 302]] for details and
              [[https://docs.python.org/3/library/importlib.html#importlib.abc.Loader][importlib.abc.Loader]] for an abstract base class.
  + path entry finder :: A finder returned by a callable on
       ~sys.path_hooks~ (i.e. a path entry hook) which knows how to locate
       modules given a path entry.
  + path entry hook :: A callable on the ~sys.path_hook~ list which returns
       a path entry finder if it knows how to find modules on a specific
       path entry.


** Module Details
   :CI:
   #+CINDEX: executable statements in modules
   #+CINDEX: module initialization
   #+CINDEX: symbol table, modules
   #+CINDEX: import, module in module
   #+CINDEX: @code{importlib.reload()}
   :END:

*** Executable Statements
    A module can contain executable statements as well as function
    definitions. These statements are intended to initialize the module. They
    are executed only the first time the module name is encountered in an
    import statement.  They are also run if the file is executed as a script.
    In fact function definitions are also ‘statements’ that are ‘executed’; the
    execution of a module-level function definition enters the function name in
    the module’s global symbol table.

*** Module Symbol Table
    Each module has its own private symbol table, which is used as the global
    symbol table by all functions defined in the module. Thus, the author of a
    module can use global variables in the module without worrying about
    accidental clashes with a user’s global variables.

*** Importing Modules and Module Attributes
    Modules can import other modules.  The imported module names are placed in
    the importing module’s global symbol table.  If the module name is followed
    by ~as~, then the name following ~as~ is bound directly to the imported
    module, i.e., ~import <module> as <alias>~.

    There is a variant of the ~import~ statement (~from <module> import <name1>,
    <name2>~) that imports names from a module directly into the importing
    module’s symbol table.  This does not introduce the module name from which
    the imports are taken in the local symbol table.  ~as~ can also be used in
    this variant.

    There is even a variant to import all names that a module defines: ~from
    <module> import *~.  This imports all names except those beginning with an
    underscore (~_~)[fn:import-star].

*** Interpreter Session
    For efficiency reasons, each module is only imported once per interpreter
    session.  Therefore, if you change your modules, you must restart the
    interpreter --- or, if it’s just one module you want to test interactively,
    use ~importlib.reload()~, e.g. ~import importlib;
    importlib.reload(modulename)~.


[fn:import-star] In most cases Python programmers do not use this facility
since it introduces an unknown set of names into the interpreter, possibly
hiding some things you have already defined.

** ~importlib~ Module
   The [[https://docs.python.org/3/library/importlib.html#module-importlib][importlib module]] provides a rich API for interacting with the import
   system.

   The Standard Library ~importlib.import_module()~ provides a recommended,
   simpler API than built-in ~__import__()~ for invoking the import machinery.

** Packages
- https://docs.python.org/3/tutorial/modules.html#packages


#+CINDEX:packages, about
#+CINDEX:name hierarchy, package
#+CINDEX:hierarchy, package name
Python has only one type of module object, and all modules are of this type.
To help organize modules and provide a naming hierarchy, Python has a
concept of *packages*.

#+TEXINFO: @heading Packages and Modules Similar to File System
#+LATEX: \subsection*{Packages and Modules Similar to File System}
You can think of /packages/ as the directories on a file system and
/modules/ as files within directories, but don’t take this analogy too
literally since packages and modules need not originate from the file
system.  Like file system directories, /packages/ are organized
hierarchically, and /packages/ may themselves contain /subpackages/, as well
as regular /modules/.

#+TEXINFO: @heading Submodules
#+LATEX: \subsection*{Submodules}
Packages are a way of structuring Python’s module namespace by using
``dotted module names''.  The module name ~A.B~ designates a submodule named
~B~ in a package name ~A~.

- ~import A.B~
- ~from A import B~


Modules within a package can be imported using dotted syntax:
: import A.B
This loads ~B~, which must be referenced with its full name:
: A.B.some_function()

When importing using the pattern ~from <package> import <item>~, as
described below, ~<item>~ can be either a submodule or subpackage or some
name defined in ~<package>~, like a function, class or variable.  The
~import~ statement first looks for a defined name in ~<package>~; if it is
not found, then it is assumed to be a module and the interpreter attempts to
load it.

Alternatively, the submodule ~B~ can be imported as:
: from A import B
~B~ can be used directly, as:
: B.some_function()

A function can be imported directly, as:
: from A.B import some_function
and it can be accessed directly as:
: some_function()

*** ~__init__.py~ Files
    :CI:
    #+CINDEX: @file{__init__.py}
    :END:
    The ~__init__.py~ files are required to make Python treat the directories
    as containing packages; this is done to prevent directories with a common
    name, such as string, from unintentionally hiding valid modules that occur
    later on the module search path.  In the simplest case, ~__init__.py~ can
    just be an empty file, but it can also execute initialization code for the
    package or set the ~__all__~ variable, described later.

*** ~__all__~ List
    :CI:
    #+CINDEX: @code{__all__}
    :END:
    If a package's ~__init__.py~ defines a list named ~__all__~, then the list
    should contain a list of module names that should be imported using the
    code:
    : from <package> import *
    If ~__all__~ is not defined, then the above code does /not/ import all
    submodules from the package; it rather ensures that the package has been
    imported (and initialized by running initialization code from
    ~__init__.py~) before importing names defined in the package, including
    submodules loaded by previous import statements.

*** Relative Imports
    #+BEGIN_EXAMPLE
    from . import <item>
    from .. import <item>
    from ..<package> import <item>
    #+END_EXAMPLE

    Relative imports are based upon the name of the current module.  Modules
    intended as the ~main~ module must always used absolute imports.

*** Multi-Directory Packages
    :CI:
    #+CINDEX: @code{__path__}
    :END:
    Packages support the special attribute ~__path__~ variable.  This variable
    is initialied to hold the name of the directory holding the package's
    ~__init__.py~.  This variable can be modified; doing so affects future
    searches for modules and packages contained in the package.

** Import Hooks --- PEP 302
   There are two types of import hooks: Meta hooks and Path hooks.

   - Meta Hooks :: called at the start of import processing, before any other
                   import processing (so that meta hooks can override
                   ~sys.path~ processing, frozen modules, or even built-in
                   modules).  To register a meta hook, simply add the finder
                   object to ~sys.meta_path~ (the list of registered meta
                   hooks).
   - Path Hooks :: called as part of ~sys.path~ (or ~package.__path__~)
                   processing, at the point where their associated path item is
                   encountered.  A path hook is registered by adding an
                   importer factory to ~sys.path_hooks~ list.
   - ~sys.path_hooks~ :: is a list of callables, which will be checked in
        sequence to determine if they can handle a given path item.  The
        callable is called with one argument, the path item.  The callable must
        raise ~ImportError~ if it is unable to handle the path item, and return
        an importer object if it can handle the path item.
   - ~__path__~ :: If a module has a ~__path__~ attribute, the import mechanism
                   will treat it as a package.  The ~__path__~ variable is used
                   instead of ~sys.path~ when importing submodules of the
                   package.

** Module as Script
   :CI:
   #+CINDEX: script, running module as
   #+CINDEX: @code{__name__}
   #+CINDEX: @code{__main__}
   #+CINDEX: module, test script
   :END:
   When you run a Python module with
   : python fibo.py <arguments>
   the code in the module will be executed, just as if you imported it, but
   with the ~__name__~ set to ~__main__~.  That means that by adding this code
   at the end of your module, you can make the file usable as a script as well
   as an importable module.
   #+BEGIN_EXAMPLE
   if __name__ == "__main__":
     import sys
     fib(int(sys.argv[1]))
   #+END_EXAMPLE
   This is often used either to provide a convenient user interface to a
   module, or for testing purposes (running the module as a script executes a
   test suite).

** Module Search Path
   :CI:
   #+CINDEX: search path, module
   #+CINDEX: ~sys.path~ variable
   When a module is imported, the interpreter searches:
   - for a built-in module with the given name
   - for a file of the given name in a list of directories given by the
     variable ~sys.path~, which is initialized with:
     + the current directory;
     + the directory containing the input script[fn:script-dir];
     + @@texinfo:@env{PYTHONPATH}@@
     + the installation-dependent default


   After initialization, Python programs can modify ~sys.path~. The directory
   containing the script being run is placed at the beginning of the search
   path, ahead of the standard library path.  This means that scripts in that
   directory will be loaded instead of modules of the same name in the library
   directory.  This is an error unless the replacement is intended. See section
   [[https://docs.python.org/3/tutorial/modules.html#tut-standardmodules][Standard Modules]] for more information.

[fn:script-dir] On file systems which support symlinks, the directory
containing the input script is calculated after the symlink is followed. In
other words the directory containing the symlink is not added to the module
search path.

** Compile Python Files
   :CI:
   #+CINDEX: @code{__pycache__}
   :END:
   To speed up loading modules, Python caches the compiled version of each
   module in the ~__pycache__~ directory under the name ~module.version.pyc~,
   where the version encodes the format of the compiled file; it generally
   contains the Python version number.  Python checks the modification date of
   the source against the compiled version to see if it’s out of date and needs
   to be recompiled. This is a completely automatic process.  A program doesn’t
   run any faster when it is read from a ~.pyc~ file than when it is read from
   a ~.py~ file; the only thing that’s faster about ~.pyc~ files is the speed
   with which they are loaded.  The module ~compileall~ can create ~.pyc~ files
   for all modules in a directory.

   Python does not check the cache in two circumstances.
   1. it always recompiles and does not store the result for the module that’s
      loaded directly from the command line.
   2. it does not check the cache if there is no source module.  To support a
      non-source (compiled only) distribution, the compiled module must be in
      the source directory, and there must not be a source module.

** Standard Modules
   :CI:
   #+CINDEX: standard library
   #+CINDEX: library reference
   :END:
   Python comes with a library of standard modules, described in the Python
   [[https://docs.python.org/3/library/index.html][Library Reference]].

*** Built-in Modules
    :CI:
    #+CINDEX: @code{sys}
    #+CINDEX: @code{sys.path}
    #+CINDEX: @env{PYTHONPATH}
    :END:
    Some modules are built into the interpreter, to provide access to
    operations that are not part of the core language but are needed for
    efficiency or to provide access to operating system primitives, such as
    system calls.

    ~sys~ is an important built-in module that provides the
    ~sys.path~ list.  Its default falue is obtained from the environment
    variable ~PYTHONPATH~.  ~sys.path~ can be modified:
    #+BEGIN_EXAMPLE
    import sys
    sys.path.append('<new-path>')
    #+END_EXAMPLE

    ~dir()~ is a build-in function that lists which names a module defines.
    Without argument, it lists names you have currently defined.  It lists all
    types of names: variables, modules, functions.  It does not list built-in
    names.  To do so, give it the argument ~__builtins__~.

* Expressions
** Arithmetic Conversions
   The phrase “the numeric arguments are converted to a common type,” this
   means that the operator implementation for built-in types works as follows:
   - If either argument is a complex number, the other is converted to complex;
   - otherwise, if either argument is a floating point number, the other is
     converted to floating point;
   - otherwise, both must be integers and no conversion is necessary.

** Atoms
   - Atoms :: most basic element of an expression
   - Simplist Atoms :: identifiers or literals; forms enclosed in parentheses,
                       brackets or braces


*** Identifiers
    - An /identifier/ occurring as an atom is a *name*.
    - When the *name* is bound to an /object/, *evaluation* of the atom yields
      that object.
    - When a name is not bound, an attempt to evaluate it raises a ~NameError~
      exception.
    - *Private name mangling* --- When an identifier that textually occurs in a
      class definition begins with two or more underscore characters and does
      not end in two or more underscores, it is considered a ~private name~ of
      that class.  Private names are transformed to a longer form before code
      is generated for them.  The transformation inserts the class name, with
      leading underscores removed and a single underscore inserted, in front of
      the name.  For example, the identifier ~__spam~ occurring in a class
      named ~Ham~ will be transformed to ~_Ham__spam~.


*** Literals
    - Python supports string and bytes literals and various numeric literals
    - Evaluation of a literal yields an object of the given type (string,
      bytes, integer, floating point number, complex number) with the given
      value.
    - All literals correspond to immutable data types, and hence the object’s
      identity is less important than its value.


*** Parenthesized Forms
    - A parenthesized form is an optional expression list enclosed in
      parentheses;
    - A parenthesized expression list yields whatever that expression list
      yields: if the list contains at least one comma, it yields a tuple;
      otherwise, it yields the single expression that makes up the expression
      list.
    - An empty pair of parentheses yields an empty tuple object.
    - Note that tuples are not formed by the parentheses, but rather by use of
      the comma operator. The exception is the empty tuple, for which
      parentheses are required.


*** Displays for Lists • Sets • Dictionaries
    :CI:
    #+CINDEX: display
    #+CINDEX: comprehension, list
    :END:
    For constructing a list, a set or a dictionary Python provides special
    syntax called
    @@texinfo:@dfn{@@@@latex:\textbf{@@displays@@texinfo:}@@@@latex:}@@, each
    of them in two flavors:
    - either the container contents are listed explicitly, or
    - they are computed via a set of looping and filtering instructions, called
      a /comprehension/.
    - The comprehension consists of a single expression followed by at least
      one ~for~ clause and zero or more ~for~ or ~if~ clauses.
    - In this case, the elements of the new container are those that would be
      produced by considering each of the ~for~ or ~if~ clauses a block,
      nesting from left to right, and evaluating the expression to produce an
      element each time the innermost block is reached.
    - Example:
      : [x*y for x in range(10) for y in range(x, x+10)]
    - To ensure the comprehension always results in a container of the
      appropriate type, ~yield~ and ~yield from~ expressions are prohibited in
      the implicitly nested scope;
    - Since Python 3.6, in an ~async def~ function, an ~async for~ clause may
      be used to iterate over an asynchronous iterator.


**** List Comprehensions
     List comprehensions provide a concise way to create lists.

     For example, to create a list of squares:
     : squares = list(map(lambda x: x**2, range(10)))
     but better is, as more concise and readable:
     : squares = [x**2 for x in range(10)]

***** Common applications
      - to make new lists where each element is the result of some operations
        applied to each member of another sequence or iterable; or
      - to create a subsequence of those elements that satisfy a certain
        condition.


***** General Definition
      - List comprehension: :: consists of brackets containing an expression
           followed by a ~for~ clause, then zero or more ~for~ or ~if~ clauses.
      - Result: :: a new list resulting from evaluating the expression in the
                   context of the ~for~ and ~if~ clauses which follow it.
      - Example: :: this listcomp combines the elements of two lists if they are
                    not equal:
                    : >>> [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]
                    : [(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]

      The above comprehension is equivalent to:

      #+BEGIN_SRC python
     combs = []
     for x in [1,2,3]:
         for y in [3,1,4]:
             if x != y:
                 combs.append((x, y))
     combs
     [(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
      #+END_SRC

***** About

      The order of the ~for~ and ~if~ statements is the same in both these
      snippets.  If the expression is a tuple (e.g. the ~(x, y)~ in the previous
      example), it must be parenthesized.  List comprehensions can contain
      complex expressions and nested functions.
      : from math import pi
      : [str(round(pi, i)) for i in range(1, 6)]
      : ['3.1', '3.14', '3.142', '3.1416', '3.14159']


**** Nested List Comprehensions
     The initial expression in a list comprehension can be any arbitrary
     expression, including another list comprehension.

** Primaries
   #+cindex: primary
   {{{dfn(Primaries)}}} represent the most tightly bound operations of the
   language.
   : primary ::=  atom | attributeref | subscription | slicing | call

*** Attribute References
    #+cindex: attribute reference
    #+CINDEX:@code{__getattr__()} method
    An {{{dfn(attribute reference)}}} is a primary followed by a period and a
    name:
    : attributeref ::=  primary "." identifier
    - The /primary/ must evaluate to an object of a type that supports attribute
      references, which most objects do.
    - This object is then asked to produce the attribute whose name is the
      /identifier/.
      #+cindex: ~__getattr__()~ method
    - This production can be customized by overriding the ~__getattr__()~
      method.

*** Subscriptions
    #+cindex: subscription
    A {{{dfn(subscription)}}} selects an item of a sequence (string, tuple or
    list) or mapping (dictionary) object:
    : subscription ::=  primary "[" expression_list "]"
    - The primary must evaluate to an object that supports subscription (lists
      or dictionaries for example).
      #+cindex: @code{__getitem__()} method
    - User-defined objects can support subscription by defining a
      ~__getitem__()~ method.
    - For built-in objects, there are two types of objects that support
      subscription:
      1. If the primary is a *mapping*, the expression list must evaluate to an
         object whose value is one of the keys of the mapping, and the
         subscription selects the value in the mapping that corresponds to that
         key. (The expression list is a tuple except if it has exactly one
         item.)
      2. If the primary is a *sequence*, the expression list must evaluate to
         an integer or a slice (as discussed in the following section).
      #+subscriptions, negative indices
    - Built-in sequences all provide a ~__getitem__()~ method that interprets
      negative indices by adding the length of the sequence to the index (so
      that =x[-1]= selects the last item of x).  The resulting value must be a
      nonnegative integer less than the number of items in the sequence, and
      the subscription selects the item whose index is that value (counting
      from zero).
    - Since the support for negative indices and slicing occurs in the object’s
      ~__getitem__()~ method, subclasses overriding this method will need to
      explicitly add that support.

*** Slicings
    #+cindex: slicing
    A {{{dfn(slicing)}}} selects a range of items in a sequence object (e.g., a
    string, tuple or list).  Slicings may be used as expressions or as targets
    in assignment or ~del~ statements.
    : slicing      ::=  primary "[" slice_list "]"
    : slice_list   ::=  slice_item ("," slice_item)* [","]
    : slice_item   ::=  expression | proper_slice
    : proper_slice ::=  [lower_bound] ":" [upper_bound] [ ":" [stride] ]


**** Slicing Semantics
     - The primary is indexed (using the same ~__getitem__()~ method as normal
       subscription) with a key that is constructed from the slice list, as
       follows.
       + If the slice list contains at least one comma, the key is a tuple
         containing the conversion of the slice items;
       + otherwise, the conversion of the lone slice item is the key.
     - The conversion of a slice item that is an expression is that expression.
     - The conversion of a proper slice is a slice object (see section The
       standard type hierarchy) whose ~start~, ~stop~ and ~step~ attributes are
       the values of the expressions given as lower bound, upper bound and
       stride, respectively, substituting ~None~ for missing expressions.

*** Calls
    #+cindex: callable object
    #+cindex: object, callable
    #+cindex: function, callable object
    A call /calls/ a {{{dfn(callable object)}}} (e.g., a function) with a
    possibly empty series of arguments.  A call always returns some value,
    possibly ~None~, unless it raises an exception.
    : call                 ::=  primary "(" [argument_list [","] | comprehension] ")"
    : argument_list        ::=  positional_arguments ["," starred_and_keywords] ["," keywords_arguments]
    :                           | starred_and_keywords ["," keywords_arguments]
    :                           | keywords_arguments
    : positional_arguments ::=  ["*"] expression ("," ["*"] expression)*
    : starred_and_keywords ::=  ("*" expression | keyword_item) ("," "*" expression | "," keyword_item)*
    : keywords_arguments   ::=  (keyword_item | "**" expression) ("," keyword_item | "," "**" expression)*
    : keyword_item         ::=  identifier "=" expression

    - The primary must evaluate to a /callable object/ (user-defined functions,
      built-in functions, methods of built-in objects, class objects, methods
      of class instances, and all objects having a ~__call__()~ method are
      /callable/).
    - All argument expressions are evaluated before the call is attempted.
    - If /keyword arguments/ are present, they are first converted to
      positional arguments.
    - If there are more /positional arguments/ than there are formal parameter
      slots, a ~TypeError~ exception is raised, unless a formal parameter using
      the syntax ~*identifier~ is present; in this case, that formal parameter
      receives a *tuple* containing the excess positional arguments (or an
      empty tuple if there were no excess positional arguments).
    - If any /keyword argument/ does not correspond to a formal parameter name, a
      ~TypeError~ exception is raised, unless a formal parameter using the
      syntax ~**identifier~ is present; in this case, that formal parameter
      receives a *dictionary* containing the excess keyword arguments (using
      the keywords as keys and the argument values as corresponding values), or
      a (new) empty dictionary if there were no excess keyword arguments.
    - If the syntax ~*expression~ appears in the function call, expression must
      evaluate to an /iterable/.
    - Functions can be called using /keyword arguments/ of the form
      ~kwarg=value~.  In a function call, keyword arguments must follow
      positional arguments.
    - When a final formal parameter of the form ~**name~ is present, it
      receives a dictionary (see Mapping Types — dict) containing all /keyword
      arguments/ except for those corresponding to a formal parameter.
    - This may be combined with a formal parameter of the form ~*name~ which
      receives a tuple containing the positional arguments beyond the formal
      parameter list. (~*name~ must occur before ~**name~.)
    - If the syntax ~*expression~ appears in the function call, ~expression~
      must evaluate to an iterable. Elements from these iterables are treated
      as if they were additional positional arguments.
    - although the ~*expression~ syntax may appear after explicit keyword
      arguments, it is processed before the keyword arguments (and any
      ~**expression~ arguments).
    - dictionaries can deliver keyword arguments with the ~**-operator~.
    - If the syntax ~**expression~ appears in the function call, ~expression~
      must evaluate to a mapping, the contents of which are treated as
      additional keyword arguments. If a keyword is already present (as an
      explicit keyword argument, or from another unpacking), a ~TypeError~
      exception is raised.

** Conditional Expressions
   #+cindex: ternary operator
   Conditional expressions (sometimes called a “ternary operator”) have the
   lowest priority of all Python operations.  The expression ~x if C else y~
   first evaluates the condition, ~C~ rather than ~x~.  If ~C~ is true, ~x~ is
   evaluated and its value is returned; otherwise, ~y~ is evaluated and its
   value is returned.

** Lambda Expressions (lambda form)
   #+cindex: lambda expression (form)
   Lambda expressions (sometimes called lambda forms) are used to create
   anonymous functions. The expression ~lambda parameters: expression~ yields a
   function object.  Note that functions created with lambda expressions cannot
   contain statements or annotations. [fn:3]

** Expression Lists
   An expression list containing at least one comma yields a tuple. The length
   of the tuple is the number of expressions in the list. The expressions are
   evaluated from left to right.

   #+cindex: iterable unpacking
   An asterisk ~*~ denotes {{{dfn(iterable unpacking)}}}. Its operand must be
   an iterable. The iterable is expanded into a sequence of items, which are
   included in the new tuple, list, or set, at the site of the unpacking.

   #+cindex: singleton
   #+cindex: tuple single
   #+cindex: tuple, empty
   The trailing comma is required only to create a single tuple (a.k.a. a
   {{{dfn(singleton)}}}; it is optional in all other cases.  A single
   expression without a trailing comma doesn’t create a tuple, but rather
   yields the value of that expression.  To create an empty tuple, use an empty
   pair of parentheses: ~()~.
* Statements
  A simple statement is comprised within a single logical line. Several simple
  statements may occur on a single line separated by semicolons.

** Syntax
     #+cindex: expression, definition
     #+cindex: procedure, definition
   - Expression statement ::
        {{{dfn(Expression statements)}}} are used (mostly interactively) to
        compute and write a value, or (usually) to call a {{{dfn(procedure)}}}
        (a function that returns no meaningful result; in Python, procedures
        return the value ~None~).  An expression statement evaluates the
        expression list (which may be a single expression).

        #+cindex: interactive mode
        #+cindex: @command{repr}
        In *interactive mode*, if the value is not ~None~, it is converted to a
        string using the built-in ~repr()~ function and the resulting string is
        written to standard output on a line by itself (except if the result is
        ~None~, so that procedure calls do not cause any output.)


   - assert statement
   - assignment statement
     + augmented assignment statement
     + annotated assignment statement
   - pass statement
   - delete statement
   - return statement
   - yield statement
   - raise statement
   - break statement
   - continue statement
   - import statement
   - future statement
   - global statement
   - nonlocal statement

#+CINDEX:statement, simple
A simple statement is comprised within a single logical line.  Several simple
statements may occur on a single line separated by semicolons.

** Expression Statement
#+cindex: expression statement, definition
#+cindex: procedure, definition
#+CINDEX:statement, expression
#+CINDEX:@code{None}
#+cindex: interactive mode
{{{dfn(Expression statements)}}} are used (mostly interactively) to compute and
write a value, or (usually) to call a {{{dfn(procedure)}}} (a function that
returns no meaningful result; in Python, procedures return the value ~None~).
In interactive mode, if the value is not ~None~, it is converted to a string
using the built-in ~repr()~ function and the resulting string is written to
standard output on a line by itself.

An expression statement evaluates the /expression list/ (which may be a single
expression).

** Assignment Statement
- [[https://docs.python.org/3/reference/simple_stmts.html?highlight=return#assignment-statements][Reference]]

#+CINDEX:assignment statement, definition
{{{dfn(Assignment statements)}}} are used to (re)bind names to values
and to modify attributes or items of mutable objects.

An assignment statement evaluates the /expression list/ (remember that this can
be a single expression or a comma-separated list, the latter yielding a tuple)
and assigns the single resulting object to each of the target lists, from left
to right.

Assignment is defined recursively depending on the form of the target
(list).  When a target is part of a mutable object (an attribute
reference, subscription or slicing), the mutable object must ultimately
perform the assignment and decide about its validity, and may raise an
exception if the assignment is unacceptable.

Assignment of an object to a target list, optionally enclosed in
parentheses or square brackets, is recursively defined...

- single target, no trailing comma: object assigned to target

- else object must be iterable with same number of items as targets in target
  list: items are assigned left to right to corresponding targets

  - if list contains a "starred target" (one target prefixed with an asterisk):
    object must be iterable with at least as many items as targets in target
    list minus one; items assigned left to right to targets before starred
    target; final items assigned to targets afer starred target; a list of the
    remaining items in the iterable is assigned to the starred target (list can
    be empty)

  - else object must be an iterable with same number of items as targets in
    target list; items assigned left to right to corresponding targets

Assignment of an object to a single target is recursively defined...

- target is identifier:

  - if name is not global or nonlocal: name is bound to object in current local
    namespace

  - otherwise: name is bound to object in the global namespace or out namespace
    determined by nonlocal

    The name is rebound if it was already bound. This may cause the reference
    count for the object previously bound to the name to reach zero, causing
    the object to be deallocated and its destructor (if it has one) to be
    called.

- target is an attribute reference:

  - The primary expression in the reference is evaluated. It should yield an
    object with assignable attributes; (otherwise =TypeError=).  That object is
    then asked to assign the assigned object to the given attribute; (otherwise
    =AttributeError=).

- target is a subscription:

  - The primary expression in the reference is evaluated. It should yield
    either a mutable sequence object (such as a list) or a mapping object (such
    as a dictionary). Next, the subscript expression is evaluated.

    - If the primary is a mutable sequence object (such as a list), the
      subscript must yield an integer.  If it is negative, the sequence’s
      length is added to it.  The resulting value must be a nonnegative
      integer less than the sequence’s length, and the sequence is asked to
      assign the assigned object to its item with that index (possible
      =IndexError=).

    - If the primary is a mapping object (such as a dictionary), the subscript
      must have a type compatible with the mapping’s key type, and the mapping
      is then asked to create a key/datum pair which maps the subscript to the
      assigned object. This can either replace an existing key/value pair with
      the same key value, or insert a new key/value pair (if no key with the
      same value existed).  For user-defined objects, the =__setitem__()=
      method is called with appropriate arguments.

- target is a slicing:

  - The primary expression in the reference is evaluated. It should yield a
    mutable sequence object (such as a list).  The assigned object should be a
    sequence object of the same type.

  - Next, the lower and upper bound expressions are evaluated, insofar they are
    present; defaults are zero and the sequence’s length. The bounds should
    evaluate to integers. If either bound is negative, the sequence’s length is
    added to it. The resulting bounds are clipped to lie between zero and the
    sequence’s length, inclusive.

  - Finally, the sequence object is asked to replace the slice with the items
    of the assigned sequence. The length of the slice may be different from the
    length of the assigned sequence, thus changing the length of the target
    sequence, if the target sequence allows it.


*** Augmented Assignment Statements
#+CINDEX:augmented assignment
Augmented assignment is the combination, in a single statement, of a binary
operation and an assignment statement.

#+begin_example
+=
-=
*=
@=
/=
//=
%=
**=
>>=
<<=
&=
^=
|=
#+end_example

An augmented assignment evaluates the target (which, unlike normal assignment
statements, cannot be an unpacking) and the expression list, performs the
binary operation specific to the type of assignment on the two operands, and
assigns the result to the original target. The target is only evaluated once.

Unlike normal assignments, augmented assignments evaluate the left-hand side
before evaluating the right-hand side. For example,
: a[i] += f(x)
first looks-up =a[i]=, then it evaluates =f(x)= and performs the addition, and
lastly, it writes the result back to =a[i]=.

*** Annotated Assignment Statements
#+CINDEX:annotated assignment
Annotation assignment is the combination, in a single statement, of a variable
or attribute annotation and an optional assignment statement.

The difference from normal Assignment statements is that only single target and
only single right hand side value is allowed.

*** Assert Statement
Assert statements are a convenient way to insert debugging assertions into a
program:
: assert <expression>
which is equivalent to
: if __debug__:
:     if not <expression>: raise AssertionError

#+CINDEX:@code{__debug__}
#+CINDEX:optimization
- In the current implementation, the built-in variable =__debug__= is =True=
  under normal circumstances, =False= when /optimization/ is requested (command
  line option {{{option(-O)}}}).

- The current code generator emits no code for an ~assert~ statement when
  /optimization/ is requested at compile time.

*** Pass Statement
#+CINDEX:@code{pass} statement
~pass~ is a null operation---when it is executed, nothing happens.
: pass

*** Delete Statement
#+CINDEX:@code{del} statement
#+CINDEX:delete
Deletion is recursively defined very similar to the way assignment is defined.
: del <target_list>

*** Return Statement
~return~ leaves the current function call with the expression list (or =None=)
as return value.  If an expression list is present, it is evaluated, else
=None= is substituted.
: return [<expression_list>]

**** Return Statement in a Generator Function
In a generator function, the return statement indicates that the generator is
done and will cause =StopIteration= to be raised.  The returned value (if any) is
used as an argument to construct =StopIteration= and becomes the
=StopIteration.value= attribute.

**** Return Statement in an Asynchronous Generator Function
In an asynchronous generator function, an empty return statement indicates that
the asynchronous generator is done and will cause =StopAsyncIteration= to be
raised.  A non-empty return statement is a syntax error in an asynchronous
generator function.

**** Yield Statement
A yield statement is semantically equivalent to a yield expression. The yield
statement can be used to omit the parentheses that would otherwise be required
in the equivalent yield expression statement.
: yield <expr>
: yield from <expr>

- raise statement
- break statement
- continue statement
- import statement
- future statement
- global statement
- nonlocal statement

** Compound Statement
#+cindex:compount statement
#+cindex:statement, compound
Compound statements contain (groups of) other statements; they affect or
control the execution of those other statements in some way.

*** Summary of Compound Statements
#+cindex:@code{if} statement
#+cindex:@code{while} statement
#+cindex:@code{for} statement
~if~, ~while~, and ~for~ statements implement traditional control flow
constructs.

#+cindex:@code{try} statement
~try~ specifies exception handlers and/or cleanup code for a group of
statements.

#+cindex:@code{while} statement
the ~with~ statement allows the execution of initialization and finalization
code around a block of code.

#+cindex:function definition, compound statement
#+cindex:class definition, compound statement
Function and class definitions are also syntactically compound statements.

*** List of Compound Statements
- ~if~

- ~while~

- ~for~

- ~try~

- ~with~

- ~funcdef~

- ~classdef~

- ~async_with~

- ~async_for~

- ~async_funcdef~

*** Description of Compound Statement
#+cindex:clause, compound statement
- clauses ::

             A compound statement consists of one or more ‘clauses.’  A clause
             consists of a header and a ‘suite.’

#+cindex:header, compound statement
- header ::

            The clause headers of a particular compound statement are all at
            the same indentation level.  Each clause header begins with a
            uniquely identifying keyword and ends with a colon.

#+cindex:suite, compound statement
- suite ::

           A suite is a group of statements controlled by a clause.  A suite
           can be one or more semicolon-separated simple statements on the same
           line as the header, following the header’s colon, or it can be one
           or more indented statements on subsequent lines.  Only the latter
           form of a suite can contain nested compound statements;


Statements always end in a NEWLINE possibly followed by a DEDENT.

Optional continuation clauses always begin with a keyword that cannot start a
statement (there are no ambiguities).

* Resources
  :PROPERTIES:
  :APPENDIX: t
  :END:

** Python Home
- https://www.python.org/

** Getting Started
- https://www.python.org/about/gettingstarted/

There is a list of tutorials suitable for experienced programmers on the
[[http://wiki.python.org/moin/BeginnersGuide/Programmers][BeginnersGuide/Tutorials page]].

** The Python Tutorial
- https://docs.python.org/3/tutorial/index.html

#+CINDEX:tutorial
This tutorial introduces the reader informally to the basic concepts and
features of the Python language and system.  It introduces many of Python’s
most noteworthy features, and will give you a good idea of the language’s
flavor and style.  After reading it, you will be able to read and write Python
modules and programs, and you will be ready to learn more about the various
Python library modules described in The Python Standard Library.

*** Python Interpreter
Invoke a Python interpreter using:

: python3.7 (Port Python3.7.3)
: python3 (Port Python3.7.3)
: python2.7 (Port Python2.7.16)
: python2 (Port Python2.7.16)
: python (system Python2.7.10)

Stop the interpreter with an end-of-line character =Control-D= or by using ~quit()~:

: ^D

#+begin_example
? python3.7
Python 3.7.3 (default, Mar 30 2019, 03:44:34)
[Clang 9.1.0 (clang-902.0.39.2)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> ^D
#+end_example

#+CINDEX:~readline~
The interpreter’s line-editing features include interactive editing, history
substitution and code completion on systems that support ~readline~.

Some common options for starting the Python interpretor are:

- =-c= commands
- =-m= module
- =-i= interactive mode

**** Arguments to the Interpreter

- ~import sys~
- ~sys.argv[0]~ script name, command, or module
- ~sys.argv[1]~ command-line argument


#+CINDEX:@code{argv} variable
#+CINDEX:@code{sys} module
When known to the interpreter, the script name and additional arguments
thereafter are turned into a list of strings and assigned to the ~argv~ variable
in the ~sys~ module.  You can access this list by executing ~import sys~.  The
length of the list is at least one; when no script and no arguments are given,
~sys.argv[0]~ is an empty string.  Options found after =-c= command or =-m= module
are not consumed by the Python interpreter’s option processing but left in
~sys.argv~ for the command or module to handle.

**** Interactive Mode

#+CINDEX:interactive mode
When commands are read from a =tty=, the interpreter is said to be in
{{{dfn(interactive mode)}}}.  In this mode it prompts for the next command with
the primary prompt, usually three greater-than signs =(>>>=); for continuation
lines it prompts with the secondary prompt, by default three dots (=...=).

#+CINDEX:@code{_} variable
In interactive mode, the last printed expression is assigned to the variable ~_~.

*** Numbers

#+CINDEX:Number types
#+CINDEX:division operators
- int
- float
- Decimal
- Fraction
- Complex
- ~/~ division (float)
- ~//~ floor division (int)
- ~%~ remainder division

**** Numeric Literals
There are three types of numeric literals:
- integers,
- floating point numbers, and
- imaginary numbers.


There are no complex literals (complex numbers can be formed by adding a real
number and an imaginary number).

Note that numeric literals do not include a sign; a phrase like =-1= is
actually an expression composed of the unary operator =-= and the literal =1=.

***** Interger Literals
- decimal =123=
- binary =0b1001=
- octal =0o777=
- hex =0xA5F=


There is no limit for the length of integer literals apart from what can be
stored in available memory.  Underscores can be used to group digits for
enhanced readability.

***** Floating Point Literals
- =3.14=
- =10.=
- =.001=
- =1e100=
- =3.14e-10=
- =0e0=
- =3.14_15_93=

***** Imaginary Literals
- 3.14j
- 10.j
- 10j
- .001j
- 1e00j


An imaginary literal yields a complex number with a real part of 0.0.  To
create a complex number with a nonzero real part, add a floating point number
to it:
: (3+4j)

*** Strings

Python strings cannot be changed — they are immutable.  Strings may also be
created from other objects using the ~str~ constructor.  There is no separate
“character” type.

: '...'
: "..."

The only difference between the two is that within single quotes you don’t need
to escape ="= (but you have to escape =\'=) and vice versa.

String literals may span mulitple lines:
: '''...'''
: """..."""

End of lines are automatically included in the string, but it’s possible to
prevent this by adding a =\= at the end of the line.
: print("""\
: Usage: ...
: """)

Raw strings ignores special characters:
: r"..."

**** Some String Functions

- ~len()~

#+CINDEX:@code{len()} function
The built-in function ~len()~ returns the length of a string:

- ~print()~

#+CINDEX:@code{print()} function
The ~print()~ function produces a more readable output, by omitting the
enclosing quotes and by printing escaped and special characters.

**** String Operators

#+CINDEX:concatenate, string
#+CINDEX:repeat, string
- concatenate =+=
- repeat =*=


Two or more string literals (i.e. the ones enclosed between quotes) next to
each other are automatically concatenated.  This feature is particularly useful
when you want to break long strings:
: text = ('Put several strings within parentheses '
:         'to have them joined together.')

**** Indexing and Slicing

- ~str[4]~ fifth position (0,1,2,3,4)
- ~str[-1]~ last
- ~str[1:4]~ position 1 up to but not including position 4
- ~str[:4]~ starts at zero
- ~str[1:]~ ends at last character

**** Sequence Type
- https://docs.python.org/3/library/stdtypes.html#textseq

Strings are examples of /sequence types/, and support the common operations
supported by such types.

**** String Methods
- https://docs.python.org/3/library/stdtypes.html#string-methods

Strings support a large number of methods for basic transformations and
searching.

**** Formatted String Literals

#+CINDEX:formatted string literals
#+CINDEX:f-string
Also known as an =f-string=, a string literal that is prefixed with =f= or =F=.

These strings may contain replacement fields, which are expressions delimited
by curly braces ={}=.  While other string literals always have a constant
value, *formatted strings* are really /expressions/ evaluated at run time.

- ={{= or =}}= are replaced with the corresponding single curly brace.
- A single opening curly bracket ={= marks a replacement field, which starts
  with a Python expression.
- After the expression, there may be a conversion field, introduced by an
  exclamation point =!=.
- A format specifier may also be appended, introduced by a colon =:=
- A replacement field ends with a closing curly bracket =}=.
- Expressions in formatted string literals are treated like regular Python
  expressions surrounded by parentheses, with a few exceptions.
  - An empty expression is not allowed
  - a lambda expression must be surrounded by explicit parentheses.
  - Replacement expressions can contain line breaks (e.g. in triple-quoted
    strings)
  - but they cannot contain comments
- Each expression is evaluated in the context where the formatted string
  literal appears, in order from left to right.
- If a conversion is specified, the result of evaluating the expression is
  converted before formatting.
  - Conversion =!s= calls ~str()~ on the result
  - =!r= calls ~repr()~
  - and =!a= calls ~ascii()~
- The result is then formatted using the ~format()~ protocol.
  - The format specifier is passed to the =__format__()= method of the
    expression or conversion result.
  - An empty string is passed when the format specifier is omitted.
  - The formatted result is then included in the final value of the whole
    string.
  - Top-level format specifiers may include nested replacement fields.
- [[https://docs.python.org/3/library/string.html#formatspec][Format Specification Mini-Language]]

: f"He said his name is {name!r}."
: f"He said his name is {repr(name)}." # equivalent

: width = 10
: precision = 4
: value = decimal.Decimal("12.34567")
: f"result: {value:{width}.{precision}}" # nested fields
: 'result:      12.35'

: today = datetime(year=2017, month=1, day=27)
: f"{today:%B %d, %Y}"  # using date format specifier
: 'January 27, 2017'

*** Lists
#+CINDEX:list
A {{[dfn(list)}}} is a mutable list of comma-separated values (items) between
square brackets.  Lists might contain items of different types.
: squares = [1, 4, 9, 16, 25]

Lists can be indexed and sliced:
: squares[0]
: squares[-1]
: squares[-3:] # slicing returns a new list
: squares[:] # returns a new (shallow) copy of the list:

Lists also support operations like concatenation:
: squares + [36, 49, 64, 81, 100]

and methods like ~append()~:
: squares.append(11 ** 2)

List items can be changed:
: cubes = [1, 8, 27, 65, 125]
: cubes[3] = 4 ** 3 # replace the wrong value

Assignment to slices is also possible:
: letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g']
: letters[2:5] = ['C', 'D', 'E']
: ['a', 'b', 'C', 'D', 'E', 'f', 'g']
: letters[2:5] = []
: ['a', 'b', 'f', 'g']
: letters[:] = [] # clear the list

Lists can be nested:
: x = [['a', 'b', 'c'], [1, 2, 3]]
: x[0][1] # 'b'

*** Control Flow

**** =while= Loop
#+CINDEX:@code{while}
: while condition:
:    body

The =while= loop executes as long as the /condition/ remains =true=.  Any
non-zero integer value is =true=; zero is =false=.  The /condition/ may also be
a string or list value, in fact any sequence; anything with a non-zero length
is =true=, empty sequences are =false=.

The body of the loop is indented.

**** =if= Statements
#+CINDEX:@code{if}
: if condition:
:    body
: elif condition:
:    body
: else:
:    body

#+CINDEX:@code{elif}
#+CINDEX:@code{else}
#+CINDEX:@code{switch}
#+CINDEX:@code{case}
An =if … elif … elif …= sequence is a substitute for the =switch= or =case=
statements found in other languages.

**** =for= Statements
Python’s =for= statement iterates over the items of any sequence (a list or a
string), in the order that they appear in the sequence.
: for var in list:
:    body

**** =range()= Function

#+CINDEX:range
#+CINDEX:sequence
#+CINDEX:iterate
#+CINDEX:iterable object
#+CINDEX:iterator
#+CINDEX:@code{list()} function
A =range= returns an object which returns the successive items of the desired
sequence when iterated over.  We say such an object is {{{dfn(iterable)}}},
that is, suitable as a target for functions and constructs that expect
something from which they can obtain successive items until the supply is
exhausted.  The =for= statement is such an iterator.  The function =list()= is
another; it creates lists from iterables: =list(range(5)) --> [0,1,2,3,4]=.

#+CINDEX:@code{range} function
Use the =range()= function to iterate over a sequence of numbers.  It generates
arithmetic progressions:
: for i in range(5):
:    print(i)

#+CINDEX:@code{len()} function
To iterate over the indices of a sequence, you can combine =range()= and
=len()= as follows:
: for i in range(len(a)):
:    print(i, a[i])

#+CINDEX:@code{enumeate()} function
In most such cases, however, it is convenient to use the =enumerate()=
function.

**** =break= and =continue= Statements--- =else= Clause on Loops

#+CINDEX:@code{break} statement
The =break= statement breaks out of the innermost enclosing =for= or =while=
loop.

#+CINDEX:@code{else} clause, loop statement
Loop statements may have an =else= clause; it is executed when the loop
terminates through exhaustion of the list (with =for=) or when the condition
becomes =false= (with =while=), but not when the loop is terminated by a
=break= statement.

#+begin_src python -n
  for n in range(2, 10):
      for x in range(2, n):
          if n % x == 0:
              print(n, 'equals', x, '*', n//x)
              break

          else:
              # loop fell through without finding a factor
              print(n, 'is a prime number')
#+end_src

When used with a loop, the =else= clause has more in common with the =else=
clause of a =try= statement than it does that of =if= statements: a =try=
statement’s =else= clause runs when no exception occurs, and a loop’s =else=
clause runs when no =break= occurs.  For more on the =try= statement and
=exceptions=, see [[https://docs.python.org/3/tutorial/errors.html#tut-handling][Handling Exceptions]].

#+CINDEX:@code{continue} statement
The =continue= statement continues with the next iteration of the loop.

**** =pass= Statement
The =pass= statement does nothing.  It can be used when a statement is required
syntactically but the program requires no action.
: while True:
:    pass

This is commonly used for creating minimal classes:
: class MyEmptyClass:
:    pass

*** Defining Functions
#+CINDEX:@code{def} keyword
#+CINDEX:function definition
The keyword =def= introduces a function definition.  It must be followed by the
function name and the parenthesized list of formal parameters.
: def func(par):
:    """This is a docstring"""
:    body

#+CINDEX:docstring
The first statement of the function body can optionally be a string literal;
this string literal is the function’s documentation string, or /docstring/
([[https://docs.python.org/3/tutorial/controlflow.html#tut-docstrings][Documentation Strings]]).

#+CINDEX:symbol tables
#+CINDEX:local symbol table
#+CINDEX:global symbol table
#+CINDEX:local variables
The execution of a function introduces a new symbol table used for the local
variables of the function.  More precisely, all variable assignments in a
function store the value in the local symbol table; whereas variable references
first look in the local symbol table, then in the local symbol tables of
enclosing functions, then in the global symbol table, and finally in the table
of built-in names.  Thus, *global variables cannot be directly assigned a value
within a function* (unless named in a global statement), although they may be
referenced.

When a function calls another function, a new local symbol table is created for
that call.

A function definition introduces the function name in the current symbol table.
The value of the function name has a type that is recognized by the interpreter
as a user-defined function.  This value can be assigned to another name which
can then also be used as a function.  This serves as a general renaming
mechanism.

**** Parameters
#+CINDEX:parameters
#+CINDEX:call by value
The actual parameters (arguments) to a function call are introduced in the
local symbol table of the called function when it is called; thus, arguments
are passed using /call by value/ (where the value is always an object
reference, not the value of the object).  /Call by object reference/ would be a
better description, since if a mutable object is passed, the caller will see
any changes the callee makes to it (items inserted into a list).

**** Return

Even functions without a return statement do return a value, albeit a rather
boring one.  This value is called =None= (it’s a built-in name).  Writing the value
=None= is normally suppressed by the interpreter if it would be the only value
written.  You can see it if you really want to using ~print()~:
: fib(0)
: print(fib(0)) --> None

- The =return= statement returns with a value from a function.  =return=
  without an expression argument returns =None=.  Falling off the end of a
  function also returns =None=.

** Resources for Programmers
- https://wiki.python.org/moin/BeginnersGuide/Programmers

The tutorials on this page are aimed at people who have previous experience
with other programming languages (C, Perl, Lisp, Visual Basic, etc.).

** Python HOWTO s
- https://docs.python.org/3/howto/index.html

Python HOWTOs are documents that cover a single, specific topic, and attempt to
cover it fairly completely.  Modelled on the Linux Documentation Project’s HOWTO
collection, this collection is an effort to foster documentation that’s more
detailed than the Python Library Reference.

- Porting Python 2 Code to Python 3
- Porting Extension Modules to Python 3
- Curses Programming with Python
- Descriptor HowTo Guide
- Functional Programming HOWTO
- Logging HOWTO
- Logging Cookbook
- Regular Expression HOWTO
- Socket Programming HOWTO
- Sorting HOW TO
- Unicode HOWTO
- HOWTO Fetch Internet Resources Using The urllib Package
- Argparse Tutorial
- An introduction to the ipaddress module
- Argument Clinic How-To
- Instrumenting CPython with DTrace and SystemTap

** Online Documentation
*** Python 3.7.3 documentation
- https://docs.python.org/3/

*** Python 3 Language Reference
- https://docs.python.org/3/reference/index.html

#+CINDEX:standard library
This library reference manual describes the standard library that is
distributed with Python.  It also describes some of the optional components
that are commonly included in Python distributions.

#+CINDEX:built-in modules
#+CINDEX:modules, built-in
The library contains built-in modules (written in C) that provide access to
system functionality such as file I/O that would otherwise be inaccessible to
Python programmers, as well as modules written in Python that provide
standardized solutions for many problems that occur in everyday programming.

Some of these modules are explicitly designed to encourage and enhance the
portability of Python programs by abstracting away platform-specifics into
platform-neutral APIs.

#+CINDEX:package tools
#+CINDEX:tools, packaging
For Unix-like operating systems Python is normally provided as a collection of
packages, so it may be necessary to use the packaging tools provided with the
operating system to obtain some or all of the optional components.

#+CINDEX:Python Package Index
In addition to the standard library, there is a growing collection of several
thousand components (from individual programs and modules to packages and
entire application development frameworks), available from the [[https://pypi.org/][Python Package
Index]].

** About the Python Standard Library
The “Python library” contains several different kinds of components.

#+CINDEX:data types, standard libreary
- data types ::

                It contains data types that would normally be considered part
                of the “core” of a language, such as numbers and lists.  For
                these types, the Python language core defines the form of
                literals and places some constraints on their semantics, but
                does not fully define the semantics.

- functions and exceptions ::

     The library also contains built-in functions and exceptions --- objects
     that can be used by all Python code without the need of an =import=
     statement.  Some of these are defined by the core language, but many are
     not essential for the core semantics and are only described here.

- modules ::

             The bulk of the library, however, consists of a collection of
             modules.

             - Some modules are written in C and built in to the Python
               interpreter;

             - others are written in Python and imported in source form.

             - Some modules provide interfaces that are highly specific to
               Python, like printing a stack trace;

             - some provide interfaces that
             are specific to particular operating systems, such as access to
             specific hardware;

             - others provide interfaces that are specific to a particular
               application domain, like the World Wide Web. Some
             modules are available in all versions and ports of Python; others
             are only available when the underlying system supports or requires
             them; yet others are available only when a particular
             configuration option was chosen at the time when Python was
             compiled and installed.

*** Python 3 Standard Library
- https://docs.python.org/3/library/index.html

*** Glossary
- https://docs.python.org/3/glossary.html

** Python's Class Development Toolkit

   - [[https://www.youtube.com/watch?v=HTLu2DFOdTg][Link]]

   - [[https://speakerdeck.com/pyconslides/pythons-class-development-toolkit-@/by-raymond-hettinger][Slides]]

   #+cindex: class toolset
   #+cindex: toolset, class creation
   #+attr_texinfo: :indic b
   - Pub Date: :: Published on Mar 20, 2013
   - Presenter: :: Raymond Hettinger
   - About: :: This is a short, but thorough tutorial on the Python's built-in
              toolset for creating classes.  We look at commonly encountered
              challenges and how to solve them using Python.

** Python Package Index---PyPi
- https://pypi.org/

*** About Installing Packages
- https://packaging.python.org/tutorials/installing-packages/

#+CINDEX:package, dfn
#+CINDEX:distribution, dfn
#+CINDEX:bundle of software
It’s important to note that the term {{{dfn(package)}}} in this context is
being used as a synonym for a {{{dfn(distribution)}}} (i.e. /a bundle of
software to be installed/), not to refer to the kind of package that you import
in your Python source code (i.e. a /container of modules/).  It is common in
the Python community to refer to a distribution using the term “package”.  Using
the term “distribution” is often not preferred, because it can easily be
confused with a Linux distribution, or another larger software distribution
like Python itself.

  #+CINDEX:distribution package
- Distribution Package ::

     #+CINDEX:versioned archive file
     #+CINDEX:archive file
     #+CINDEX:file, archive
     #+CINDEX:packages, Python
     #+CINDEX:modules
     #+CINDEX:Release
     A *versioned archive file* that contains Python /packages/, /modules/, and
     other resource files that are used to distribute a Release.  The archive
     file is what an end-user will download from the internet and install.

     #+CINDEX:package, as distribution
     #+CINDEX:distribution, as package
     #+CINDEX:import package
     A *distribution package* is more commonly referred to with the single
     words “package” or “distribution”, but this guide may use the expanded
     term when more clarity is needed to prevent confusion with an Import
     Package (which is also commonly called a “package”) or another kind of
     distribution (e.g. a Linux distribution or the Python language
     distribution), which are often referred to with the single term
     “distribution”.

  #+CINDEX:release
- Release ::

             #+CINDEX:project snapshot
             #+CINDEX:version identifier
             A snapshot of a Project at a particular point in time, denoted by
             a version identifier.

  #+CINDEX:project
- Project ::

             #+CINDEX:distribution, as project
             A library, framework, script, plugin, application, or collection
             of data or other resources, or some combination thereof that is
             intended to be packaged into a Distribution.

             Since most projects create Distributions using ~distutils~[fn::A
             package in the Python Standard Library that has support for
             creating and installing distributions. ] or ~setuptools~[fn::
             ~setuptools~ (which includes easy_install) is a collection of
             enhancements to the Python ~distutils~ that allow you to more
             easily build and distribute Python distributions, especially ones
             that have dependencies on other packages.], another practical way
             to define projects currently is something that contains a
             ~setup.py~ at the root of the project src directory, where
             “setup.py” is the project specification filename used by
             ~distutils~ and ~setuptools~.

             Python projects must have unique names, which are registered on
             PyPI.  Each project will then contain one or more *Releases*, and
             each release may comprise one or more *distributions*.

  #+CINDEX:import package
- Import Package ::

                    #+CINDEX:module
                    A Python module which can contain other modules or
                    recursively, other packages.

                    An *import package* is more commonly referred to with the
                    single word “package”, but this guide will use the expanded
                    term when more clarity is needed to prevent confusion with
                    a *Distribution Package* which is also commonly called a
                    “package”.

 #+CINDEX:module, as import package
- Module ::

            #+CINDEX:pure module
            #+CINDEX:extension module
            The basic unit of code reusability in Python, existing in one of
            two types: Pure Module, or Extension Module.

*** About Packaging Python Code
- https://packaging.python.org/tutorials/packaging-projects/

#+CINDEX:package a project
This tutorial walks you through how to package a simple Python project.  It
will show you how to add the necessary files and structure to create the
package, how to build the package, and how to upload it to the Python Package
Index.

** Popular Python Recipes
- http://code.activestate.com/recipes/langs/python/

If you are looking for common Python recipes and patterns, you can browse the
ActiveState Python Cookbook.

* Python 2 or Python 3
:PROPERTIES:
:appendix: t
:END:
- https://wiki.python.org/moin/Python2orPython3


Python 3.0 was released in 2008. The final 2.x version 2.7 release came out in
mid-2010, with a statement of extended support for this end-of-life
release. The 2.x branch will see no new major releases after that. 3.x is under
active development and has already seen over five years of stable releases,
including version 3.3 in 2012, 3.4 in 2014, 3.5 in 2015, and 3.6 in 2016. This
means that all recent standard library improvements, for example, are only
available by default in Python 3.x.

* List of Tables
  :PROPERTIES:
  :UNNUMBERED: t
  :END:
  #+TEXINFO: @listoffloats Table
* Concept Index
  :PROPERTIES:
  :index:    cp
  :END:

* Export Settings                                                  :noexport:

** Texinfo Setup                                                  :noexport:
  #+TEXINFO_FILENAME:python-the-language.info
  #+TEXINFO_CLASS: info
  #+TEXINFO_HEADER:
  #+TEXINFO_POST_HEADER:
  #+SUBAUTHOR:
  #+TEXINFO_DIR_CATEGORY:Python
  #+TEXINFO_DIR_TITLE:Python
  #+TEXINFO_DIR_DESC:Python the Language
  #+TEXINFO_PRINTED_TITLE: Python the Language
  #+OPTIONS: H:4

  #+MACRO: dfn @@texinfo:@dfn{@@$1@@texinfo:}@@
  #+MACRO: option @@texinfo:@option{@@$1@@texinfo:}@@

** LaTeX Setup                                                    :noexport:
  #+LATEX_CLASS: report
  #+LATEX_CLASS_OPTIONS:
  #+LATEX_HEADER:
  #+LATEX_HEADER_EXTRA:
  #+DESCRIPTION:
  #+KEYWORDS:
  #+LATEX_COMPILER: pdflatex

* Footnotes
[fn:3]If Guido van Rossum, the author of the programming language Python, had
got his will, there would be no ~lambda~ operator.  In his article from May
2005 [[http://www.artima.com/weblogs/viewpost.jsp?thread=98196]["All Things Pythonic: The fate of reduce() in Python 3000"]], he gives his
reasons for dropping ~lambda~, ~map()~, ~filter()~ and ~reduce()~.  He expected
resistance from the Lisp and the scheme "folks".  What he didn't anticipate was
the rigidity of this opposition.  Enough that Guido van Rossum wrote hardly a
year later: "After so many attempts to come up with an alternative for lambda,
perhaps we should admit defeat. I've not had the time to follow the most recent
rounds, but I propose that we keep lambda, so as to stop wasting everybody's
talent and time on an impossible quest."  We can see the result: lambda, map()
and filter() are still part of core Python. Only reduce() had to go; it moved
into the module ~functools~.

His reasoning for dropping them is like this:

There is an equally powerful alternative to ~lambda~, ~filter~, ~map~ and
~reduce~, i.e. [[https://www.python-course.eu/python3_list_comprehension.php][list comprehension]]

List comprehension is more evident and easier to understand.

Having both list comprehension and "Filter, map, reduce and lambda" is
transgressing the Python motto "There should be one obvious way to solve a
problem"

Some like it, others hate it and many are afraid of the lambda operator.  The
lambda operator or lambda function is a way to create small anonymous
functions, i.e. functions without a name.  These functions are throw-away
functions, i.e. they are just needed where they have been created.  Lambda
functions are mainly used in combination with the functions filter(), map() and
reduce().  The lambda feature was added to Python due to the demand from Lisp
programmers.

From [[https://www.python-course.eu/python3_lambda.php][Python Crash Course on Lambdas]]

* Local Variables                                                  :noexport:
# Local Variables:
# time-stamp-pattern:"8/^\\#\\+date:%:y-%02m-%02d %02H:%02M$"
# End:
