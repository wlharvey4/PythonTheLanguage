# -*- fill-column: 79 -*-

#+TITLE: Python the Language
#+SUBTITLE: Version {{{version}}} {{{time(%F %R)}}}
#+AUTHOR: WLHarvey4
#+DATE: <2018-12-21 Fri 03:26>
#+MACRO: version 0.2.7

#+TEXINFO_FILENAME:python-the-language.info
#+TEXINFO_CLASS: info
#+TEXINFO_HEADER:
#+TEXINFO_POST_HEADER:
#+SUBAUTHOR:
#+TEXINFO_DIR_CATEGORY:Python
#+TEXINFO_DIR_TITLE:Python
#+TEXINFO_DIR_DESC:Python the Language
#+TEXINFO_PRINTED_TITLE: Python the Language
#+OPTIONS: H:4

#+LATEX_CLASS: report
#+LATEX_CLASS_OPTIONS:
#+LATEX_HEADER:
#+LATEX_HEADER_EXTRA:
#+DESCRIPTION:
#+KEYWORDS:
#+LATEX_COMPILER: pdflatex

* Keywords
- False
- None
- True
- and
- as
- assert
- async
- await
- break
- class
- continue
- def
- del
- elif
- else
- except
- finally
- for
- from
- global
- if
- import
- in
- is
- lambda
- nonlocal
- not
- or
- pass
- raise
- return
- try
- while
- with
- yield

* Operators
Operators are the constructs which can manipulate the value of operands.

Python language supports the following types of operators.

** Arithmetic
   - addition (+) :: Adds values on either side of the operator.
   - subtraction (-) :: Subtracts right hand operand from left hand operand.
   - multiplication (*) :: Multiplies values on either side of the operator
   - division (/) :: Divides left hand operand by right hand operand
   - modulus (%) :: Divides left hand operand by right hand operand and returns remainder
   - exponent (**) :: Performs exponential (power) calculation on operators
   - floor division (//) :: Floor Division - The division of operands
        where the result is the quotient in which the digits after the
        decimal point are removed. But if one of the operands is
        negative, the result is floored, i.e., rounded away from zero
        (towards negative infinity)

** Relational
These operators compare the values on either sides of them and decide
the relation among them.
   - == :: If the values of two operands are equal, then the condition becomes true.
   - != :: If values of two operands are not equal, then condition becomes true.
   - <> :: If values of two operands are not equal, then condition becomes true.
   - > :: If the value of left operand is greater than the value of
          right operand, then condition becomes true.
   - < :: If the value of left operand is less than the value of right
          operand, then condition becomes true.
   - >= :: If the value of left operand is greater than or equal to
           the value of right operand, then condition becomes true.
   - <= :: If the value of left operand is less than or equal to the
           value of right operand, then condition becomes true.

** Assignment
   - = :: Assigns values from right side operands to left side operand
   - += Add AND :: It adds right operand to the left operand and
                   assign the result to left operand
   - -= Subtract AND :: It subtracts right operand from the left
        operand and assign the result to left operand
   - *= Multiply AND :: It multiplies right operand with the left
        operand and assign the result to left operand
   - /= Divide AND :: It divides left operand with the right operand
                      and assign the result to left operand
   - %= Modulus AND :: It takes modulus using two operands and assign
                       the result to left operand
   - **= Exponent AND :: Performs exponential (power) calculation on
        operators and assign value to the left operand
   - //= Floor AND :: It performs floor division on operators and
                      assign value to the left operand

** Logical
   - and :: If both the operands are true then condition becomes true.
   - or :: If any of the two operands are non-zero then condition
           becomes true.
   - not :: Used to reverse the logical state of its operand.

** Bitwise
   - & :: AND Operator copies a bit to the result if it exists in both
          operands
   - | :: OR Operator copies a bit if it exists in either operand.
   - ^ :: XOR Operator copies the bit if it is set in one operand but
          not both.
   - ~ :: Ones Complement s unary and has the effect of 'flipping'
          bits.
   - << :: Binary Left Shift; The left operands value is moved left by
           the number of bits specified by the right operand.
   - >> :: Binary Right Shift; The left operands value is moved right
           by the number of bits specified by the right operand.

** Membership
Python’s membership operators test for membership in a sequence, such
as strings, lists, or tuples.
    - in :: Evaluates to true if it finds a variable in the specified
            sequence and false otherwise.
    - not in :: Evaluates to true if it does not finds a variable in
                the specified sequence and false otherwise.

#+NAME: membership
#+BEGIN_SRC python -n :results output :tangle membership.py :exports both :eval no-export

  a = 10
  b = 20
  list = [1, 2, 3, 4, 5 ];

  if ( a in list ):
     print ("Line 1 - a is available in the given list")
  else:
     print ("Line 1 - a is not available in the given list")

  if ( b not in list ):
     print ("Line 2 - b is not available in the given list")
  else:
     print ("Line 2 - b is available in the given list")

  a = 2
  if ( a in list ):
     print ("Line 3 - a is available in the given list")
  else:
     print ("Line 3 - a is not available in the given list")

#+END_SRC

#+RESULTS: membership
: Line 1 - a is not available in the given list
: Line 2 - b is not available in the given list
: Line 3 - a is available in the given list
: done

** Identity
Identity operators compare the memory locations of two objects.
   - is :: Evaluates to true if the variables on either side of the
           operator point to the same object and false otherwise.

           ~x is y~, here ~is~ results in 1 if ~id(x)~ equals ~id(y)~.

   - is not :: Evaluates to false if the variables on either side of
               the operator point to the same object and true
               otherwise.

               ~x is not y~, here ~is not~ results in 1 if ~id(x)~ is
               not equal to ~id(y)~.

#+NAME: identity
#+BEGIN_SRC python -n :results output :exports both :tangle identity.py :eval no-export

#!/usr/bin/python3

a = 20
b = 20

if ( a is b ):
   print ("Line 1 - a and b have same identity")
else:
   print ("Line 1 - a and b do not have same identity")

if ( id(a) == id(b) ):
   print ("Line 2 - a and b have same identity")
else:
   print ("Line 2 - a and b do not have same identity")

b = 30
if ( a is b ):
   print ("Line 3 - a and b have same identity")
else:
   print ("Line 3 - a and b do not have same identity")

if ( a is not b ):
   print ("Line 4 - a and b do not have same identity")
else:
   print ("Line 4 - a and b have same identity")

#+END_SRC

#+RESULTS:
: Line 1 - a and b have same identity
: Line 2 - a and b have same identity
: Line 3 - a and b do not have same identity
: Line 4 - a and b do not have same identity

** Precedence
1. ~**~ Exponentiation
2. ~~ + -~ Complement, unary plus and minus (method names for the last
   two are +@ and -@)
3. ~* / % //~ Multiply, divide, modulo and floor division
4. ~+ -~ Addition and subtraction
5. ~>> <<~ Right and left bitwise shift
6. ~&~ Bitwise 'And'
7. ~^ |~ Bitwise exclusive `OR' and regular `OR'
8. ~<= < > >=~ Comparison operators
9. ~<> == !=~ Equality operators
10. ~= %= /= //= -= += *= **=~ Assignment operators
11. ~is is not~ Identity operators
12. ~in not in~ Membership operators
13. ~not or and~ Logical operators

* Delimiters
  - ~( )~
  - ~[ ]~
  - ~{ }~
  - ~'~
  - ~: . ;~
  - ~@~
  - ~=~
  - ~->~
  - ~+= -= *= /= //= %= @= &= |= ^= >>= **=~

  The augmented assignment operators serve lexically as delimiters, but also
  perform an operation.

  ~' " # \~ have special meaning in Python.

  ~$ ? `~ are not used and their use outside of a string constitutes an error.
* Data

** Data Model
:CI:
#+CINDEX: data model
#+CINDEX: objects as data
:END:

*** Objects --- Identity • Type • Value
:CI:
#+CINDEX: identity
#+CINDEX: type
#+CINDEX: value
#+CINDEX: ~is~ operator
#+CINDEX: ~id()~ function
#+CINDEX: ~type()~ function
#+CINDEX: garbage collection
:END:

/Objects/ are Python’s  abstraction for *data*.  All data  in a Python
program is represented by objects or by relations between objects.
Every object has an:

 - identity :: immutable; an object's place in memory
   - ~is~ :: operator to compare the identity of two objects
   - ~id()~  :: function that returns an integer representing
                      the object's identity.
 - type :: determines the operations that the object supports, and the
           possible values for objects of that type.
   - ~type()~ :: function returns an object's type (an object itself);
                 type is immutable
 - value :: values can be either mutable or immutable, which is
            determined by its type.  Numbers, strings, and tuples are
            /immutable/, while dictionaries and lists are /mutable/.

Objects are nevery explicitly destroyed; rather, they are
garbage-collected when they become unreachable.

*** Container Objects
:CI:
#+CINDEX: container objects
#+CINDEX: containers
#+CINDEX: containers, mutability
:END:

/Container objects/ are objects that contain references to other
objects.  Examples are:
 - tuples
 - lists
 - dictionaries

The references are part of a container’s value.  When referring to the
/mutability/ of a container, the identities of the immediately
contained objects are implied.  Thus, if an immutable container (like
a tuple) contains a reference to a mutable object, its value changes
if that mutable object is changed.

** Type Hierarchy
A discussion of the types built into Python.

*** None
 - ~None~ :: single object with a single value, accessed through the
             name ~None~.  It signifies /the absence of a value/,
             i.e., it would be returned from a function that did not
             explicitly return anything.  It's *truth* value is
             /false/.

*** NotImplemented
 - ~NotImplemented~ :: single object with a single value, accessed
      through the name ~NotImplemented~.  Numeric methods and rich
      comparison methods should return this value if they do not
      implement the operation for the operands provided.  It's *truth*
      value is /true/.

*** Ellipsis
 - ~Ellipsis~ :: single  object with a single  value, accessed through
                 the literal ... or the name ~Ellipsis~.  It's *truth*
                 value is /true/.

*** numbers.Number
These types are created by numeric literals and returned as results by
arithmetic operators and arithmetic built-in functions.  They are
immutable.  Python distinguishes between integers, floating point
numbers, and complex numbers.

**** ~numbers.Integral~
These are integers.  There are two types:

***** Integers ~int~
These represent numbers in an unlimited range, subject to available
(virtual) memory only.

***** Booleans ~bool~
These represent the truth values ~False~ and ~True~.  The Boolean type is a
subtype of the integer type, and Boolean values behave like the values 0 and 1,
respectively, in almost all contexts, the exception being that when converted
to a string, the strings "False" or "True" are returned, respectively.

**** ~numbers.Real~ • Float
These represent machine-level double precision floating point numbers.  Python
does not support single-precision floating point numbers;

**** ~numbers.Complex~ • Complex
These represent complex numbers as a pair of machine-level double precision
floating point numbers.  The real and imaginary parts of a complex number z can
be retrieved through the read-only attributes:
 - ~z.real~
 - ~z.imag~

*** Sequences
:CI:
#+CINDEX: select, sequence
#+CINDEX: slice, sequence
#+CINDEX: slice, extended, sequence
:END:
Sequences represent finite ordered sets indexed by non-negative numbers.

 - ~len()~ :: function that returns the number of items of a sequence (zero
              indexed).
 - selecting :: ~a[i]~ selects item ~i~ of sequence ~a~
 - slicing :: ~a[i:j]~ selects all items with index k such that ~i <= k < j~.
 - extended slicing :: ~a[i:j:k]~ selects all items of ~a~ with index ~x~ where
      ~x = i + n*k~, ~n >= 0~ and ~i <= x < j~.
**** Immutable Sequences
     An object of an immutable sequence type cannot change once it is created.
***** Strings
      A sequence of values that represent Unicode code points.  All the code
      points in the range =U+0000 - U+10FFFF= can be represented in a string.
      There is no ~char~ type.
      - ~ord()~ :: converts a code point from its string form to an integer in
                   the range =0 - 10FFFF=
      - ~chr()~ :: converts an integer in the range =0 - 10FFFF= to the
                   corresponding length 1 string object.
      - ~str.encode()~ :: used to convert a ~str~ to ~bytes~ using the given
                          text encoding
      - ~bytes.encode()~ :: used to convert ~bytes~ to ~str~ using the given
           text encoding
***** Tuples
      Tuples of two or more items are formed by comma-separated lists of
      expressions.  The items of a tuple are arbitrary Python objects.  A tuple
      of one item (a /singleton/) can be formed by affixing a comma to an
      expression.  An empty tuple can be formed by an empty pair of
      parentheses.
***** Bytes
      A ~bytes~ object is an immutable array.  The items are 8-bit bytes,
      represented by integers in the range ~0 <= x < 256~.  To construct a
      ~bytes~ object, use:
      - ~b'abc'~ :: ~bytes~ literal
      - ~bytes()~ :: ~bytes~ constructor
      - ~decode()~ :: method to convert a ~bytes~ object to a string
**** Mutable Sequences
     Mutable sequences can be changed after they are created.  There are two
      built-in mutable sequence types.  The extension module ~array~ provides
      an additional example of a mutable sequence type.
***** Lists
      Lists are formed by placing a comma-separated list of expressions in
      square brackets.  The items of a list are arbitrary Python objects.
***** Byte Arrays
      A mutable array.  Provide the same interface and functionality as
      immutable ~bytes~ object.  Since a ~bytearray~ is mutable, it is also
      unhashable.
      - ~bytearray()~ :: constructor
***** Arrays
      The ~array~ extension module provides efficient arrays of basic numeric
      values:
       + characters
       + integers
       + floating point numbers

      Arrays are /sequence types/ and behave very much like lists, except that
      the type of objects stored in them is constrained.  The type is specified
      at object creation time by using a type code, which is a single
      character.
****** Sequence Operations
      Array objects support the ordinary sequence operations of
       + indexing
       + slicing
       + concatenation
       + multiplication
****** Buffer Interface
       Array objects also implement the buffer interface, and may be used
       wherever ~bytes~-like objects are supported.
****** Slice Assignment
      When using slice assignment, the assigned value must be an array object
      with the same type code; in all other cases, ~TypeError~ is raised.
****** Type Codes
      The following type codes are defined:

      | Type Code | C Type               | Python Type       | Min Size (bytes) | Notes  |
      |-----------+----------------------+-------------------+------------------+--------|
      | 'b'       | signed ~char~        | ~int~             |                1 |        |
      | 'B'       | unsigned ~char~      | ~int~             |                1 |        |
      | 'u'       | ~Py_UNICODE~         | Unicode character |                2 | [fn:1] |
      | 'h'       | signed ~short~       | ~int~             |                2 |        |
      | 'H'       | unsigned ~short~     | ~int~             |                2 |        |
      | 'i'       | signed ~int~         | ~int~             |                2 |        |
      | 'I'       | unsigned ~int~       | ~int~             |                2 |        |
      | 'l'       | signed ~long~        | ~int~             |                4 |        |
      | 'L'       | unsigned ~long~      | ~int~             |                4 |        |
      | 'q'       | signed ~long long~   | ~int~             |                8 | [fn:2] |
      | 'Q'       | unsigned ~long long~ | ~int~             |                8 | [fn:2] |
      | 'f'       | ~float~              | ~float~           |                4 |        |
      | 'd'       | ~double~             | ~float~           |                8 |        |
      |-----------+----------------------+-------------------+------------------+--------|
****** Standard Library Reference
       [[https://docs.python.org/3/library/array.html#module-array][array]]

[fn:1] The 'u' type code corresponds to Python’s obsolete unicode character
(~Py_UNICODE~ which is ~wchar_t~).  Depending on the platform, it can be 16 bits or
32 bits.  'u' will be removed together with the rest of the ~Py_UNICODE~ API in
4.0.
[fn:2] The 'q' and 'Q' type codes are available only if the platform C compiler
used to build Python supports C ~long long~, or, on Windows, ~__int64~.
****** Defined Array Types
       - class array.array(/typecode/[, /initializer/]) :: A new array whose
            items are restricted by /typecode/, and initialized from the
            optional /initializer/ value, which must be a list, a ~bytes~-like
            object, or iterable over elements of the appropriate type.  If
            given a list or string, the initializer is passed to the new
            array’s ~fromlist()~, ~frombytes()~, or ~fromunicode()~ method to
            add initial items to the array.
       - array.typecodes :: a string with all available type codes.

*** Set Types
:CI:
#+CINDEX: sets
#+CINDEX: frozen sets
:END:
    Sets represent unordered, finite sets of unique, immutable objects.  They
    cannot be indexed by any subscript.  They can be iterated over.
     - ~len()~ :: returns the number of items in a set. 

    Common uses for sets are:
     - fast membership testing
     - removing duplicates from a sequence
     - computing mathematical operations such as intersection, union,
       difference, and symmetric difference

    There are currently two intrinsic set types:

**** Sets
     These represent a mutable set.
      - ~set()~ :: constructor

**** Frozen Sets
     These represent an immutable set.  They are hashable, and therefore can be
     used again as an element of another set, or as a dictionary key.
      - ~frozenset()~ :: constructor

*** Mappings
    Mappings represent finite sets of objects indexed by arbitrary index sets.

     - ~a[k]~ :: selects the item indexed by ~k~ from the mapping ~a~
     - ~len()~ :: returns the number of items in a mapping

    There is currently a single intrinsic mapping type:

**** Dictionaries
     Dictionaries represent finite sets of objects indexed by nearly arbitrary
     values.  The only types of values not acceptable as keys are values
     containing lists or dictionaries or other mutable types that are compared
     by value rather than by object identity because the efficient
     implementation of dictionaries requires a key’s hash value to remain
     constant.  They are mutable.
      - ~{ ... }~ :: dictionary constructor

     The [[https://docs.python.org/3/library/collections.html#module-collections][collections]] module provides additional mapping types.
*** Callable
:CI:
#+CINDEX: functions, user-defined, callable
#+CINDEX: functions, built-in, callable
#+CINDEX: functions, generator, callable
#+CINDEX: functions, coroutine, callable
#+CINDEX: methods, instance, callable
#+CINDEX: methods, build-in, callable
#+CINDEX: classes, callable
#+CINDEX: instance, class, callable
:END:
    These are the types to which the function call operation (see section
    Calls) can be applied.  (A call calls a callable object (e.g., a function)
    with a possibly empty series of arguments.)
**** User-defined functions
     A user-defined function object is created by a function definition.  It
     should be called with an argument list containing the same number of items
     as the function’s formal parameter list.
**** Instance methods
     An instance method object combines a class, a class instance and any
     callable object (normally a user-defined function).
**** Generator functions
     A /generator function/ is a function or method which uses the ~yield~
     statement.  Such a function, when called, always returns an iterator
     object which can be used to execute the body of the function:
      - calling the iterator’s ~iterator.__next__()~ method will cause the
        function to execute until it provides a value using the ~yield~ statement.
      - When the function executes a ~return~ statement or falls off the end, a
        ~StopIteration~ exception is raised and the iterator will have reached
        the end of the set of values to be returned.
**** Coroutine functions
     A /coroutine function/ is a function or method which is defined using
     ~async def~.  Such a function, when called, returns a ~coroutine~ object.
      - ~coroutine~ :: Coroutines is a more generalized form of
                       subroutines. Subroutines are entered at one point and
                       exited at another point. Coroutines can be entered,
                       exited, and resumed at many different points. They can
                       be implemented with the async def statement.
**** Asynchronous generator functions
     An /asynchronous generator function/ is function or method which is
     defined using ~async def~ and which uses the ~yield~ statement.  Such a
     function, when called, returns an ~asynchronous iterator object~ which can
     be used in an ~async for~ statement to execute the body of the function.
**** Built-in functions
     A built-in function object is a wrapper around a C function.  Examples of
     built-in functions are ~len()~ and ~math.sin()~.  The number and type of
     the arguments are determined by the C function.
**** Built-in methods
     This is really a different disguise of a built-in function, this time
     containing an object passed to the C function as an implicit extra
     argument.  An example of a built-in method is ~alist.append()~, assuming
     ~alist~ is a list object.
**** Classes
     Classes are callable.  These objects normally act as factories for new
     instances of themselves, but variations are possible for class types that
     override ~__new__()~.  The arguments of the call are passed to ~__new__()~
     and, in the typical case, to ~__init__()~ to initialize the new instance.
**** Class Instances
     Instances of arbitrary classes can be made callable by defining a
     ~__call__()~ method in their class.
*** Modules
    Modules are a basic organizational unit of Python code.
**** Creating Modules
     Modules are created using the:
      - import system :: invoked either by
        * the ~import~ statement; or
        * calling functions such as:
          - ~importlib.import_module()~; and
          - built-in ~__import__()~
**** Module Namespace
     A module object has a namespace implemented by a dictionary object
      + this is the dictionary referenced by the ~__globals__~ attribute of
       functions defined in the module
      + Attribute references are translated to lookups in this dictionary,
      + e.g., ~m.x~ is equivalent to ~m.__dict__["x"]~.
      + Attribute assignment updates the module’s namespace dictionary, e.g.,
        ~m.x = 1~ is equivalent to ~m.__dict__["x"] = 1~.
*** Custom Classes
    Custom class types are typically created by class definitions.  A class has
    a namespace implemented by a dictionary object.  Class attribute references
    are translated to lookups in this dictionary,
     + e.g., ~C.x~ is translated to ~C.__dict__["x"]~
     + When the attribute name is not found there, the attribute search
       continues in the base classes.

    When a class attribute reference (for class ~C~, say) would yield a class
    method object, it is transformed into an instance method object whose
    ~__self__~ attribute is ~C~.

    When it would yield a static method object, it is transformed into the
    object wrapped by the static method object.
*** Class Instance
    A class instance is created by calling a class object.  A class instance
    has a namespace implemented as a dictionary which is the first place in
    which attribute references are searched.  When an attribute is not found
    there, and the instance’s class has an attribute by that name, the search
    continues with the class attributes. If a class attribute is found that is
    a user-defined function object, it is transformed into an instance method
    object whose ~__self__~ attribute is the instance.  If no class attribute
    is found, and the object’s class has a ~__getattr__()~ method, that is
    called to satisfy the lookup.
*** I/O Objects
    A file object represents an open file.  Various shortcuts are available to
    create file objects:
     - ~open()~ built-in function
     - ~os.open()~
     - ~os.fdopen()~
     - ~makefile()~ method of socket objects

    The objects are initialized to file objects corresponding to the
    interpreter’s
     - ~sys.stdin~ --- standard input
     - ~sys.stdout~ --- standard output
     - ~sys.stderr~ --- standard error

    They are all open in text mode and therefore follow the interface defined
    by the ~io.TextIOBase~ abstract class.
*** Internal
    A few types used internally by the interpreter are exposed to the user.
**** Code objects
     Code objects represent byte-compiled executable Python code, or bytecode.
**** Frame objects
     Frame objects represent execution frames.
**** Traceback objects
     Traceback objects represent a stack trace of an exception.
**** Slice objects
     Slice objects are used to represent slices for ~__getitem__()~ methods.
     They are also created by the built-in ~slice()~ function.
**** Static method objects
     Static method objects provide a way of defeating the transformation of
     function objects to method objects described above.
**** Class method objects
     A class method object, like a static method object, is a wrapper around
     another object that alters the way in which that object is retrieved from
     classes and class instances.
     
* Execution

** Program Structure
:CI:
#+CINDEX: program
#+CINDEX: code block
#+CINDEX: block of code
#+CINDEX: execution frame
:END:
*** Program
    - program :: is constructed from code blocks
*** Code Block
    - block :: is a piece of Python program text that is executed as a unit.
      + module
      + function body
      + class definition
      + command typed interactively
      + script file (a file given as standard input to the interpreter or
        specified as a command line argument to the interpreter)
      + script command (a command specified on the interpreter command line
        with the -c option)
      + The string argument passed to the built-in functions ~eval()~ and
        ~exec()~ is a code block.
*** Execution Frame
    - execution frame :: where a code block is executed.  A frame contains some
         administrative information (used for debugging) and determines where
         and how execution continues after the code block’s execution has
         completed.

** Naming and Binding
   - name :: refers to an object; introduced by name binding operations.

*** Name Binding
    - formal parameters to functions
    - ~import~ statements
    - class and function definitions
    - targets that are identifiers if occurring in an assignmetn
    - ~for~ loop header
    - ~as~ after a ~with~ statement or ~except~ clause
    - ~from ... import *~ binds all names defined in the imported module,
      except those beginning with an underscore.
    - target occurring in a ~del~ statement is considered bound

**** Where Binding Occurs
     - where occurs :: Each assignment or import statement occurs within a
                       block defined by a class or function definition or at
                       the module level (the top-level code block).
     - local variable :: If a name is bound in a block, it is a local variable
                         of that block
     - ~nonlocal~ or ~global~ declaration :: unless declared as nonlocal or
          global
     - global variable :: If a name is bound at the module level, it is a
          global variable.
     - module level :: The variables of the module code block are local and
                       global.
     - free variable :: a variable used in a code block but not defined there

*** Name Resolution
    Python lacks declarations and allows name binding operations to occur
    anywhere within a code block.

    Each occurrence of a name in the program text refers to the binding of that
    name established by the following name resolution rules.

    - scope :: defines the visibility of a name within a block
      + local variable :: If a local variable is defined in a block, its scope
                          includes that block.  If the definition occurs in a
                          function block, the scope extends to any blocks
                          contained within the defining one, unless a contained
                          block introduces a different binding for the name.
    - resolution :: When a name is used in a code block, it is resolved using
                    the nearest enclosing scope.
    - block environment :: The set of all such scopes visible to a code block
         is called the block’s environment.
    - ~NameError~ Exception :: the exception raised when a name is not found at
         all.
    - ~UnboundLocalError~ Exception :: the error raised when if the current
         scope is a function scope, and the name refers to a local variable
         that has not yet been bound to a value at the point where the name is
         used.  This is a subclass of ~NameError~ exception.

**** References to the Current Block
     If a name binding operation occurs anywhere within a code block, all uses
     of the name within the block are treated as references to the current
     block.  This can lead to errors when a name is used within a block before
     it is bound.  This rule is subtle.

     The /local variables/ of a code block can be determined by scanning the
     entire text of the block for name binding operations.

**** Global Variables
     - global statement :: If the ~global~ statement occurs within a block, all
          uses of the name specified in the statement refer to the binding of
          that name in the top-level namespace.  Names are resolved in the
          top-level namespace by searching the global namespace, i.e. the
          namespace of the module containing the code block, and the builtins
          namespace, the namespace of the module ~builtins~.  The global
          namespace is searched first.  If the name is not found there, the
          builtins namespace is searched.  The ~global~ statement must precede
          all uses of the name.  The ~global~ statement has the same scope as a
          name binding operation in the same block. If the nearest enclosing
          scope for a free variable contains a global statement, the free
          variable is treated as a global.
     - nonlocal statement :: The ~nonlocal~ statement causes corresponding names
          to refer to previously bound variables in the nearest enclosing
          function scope.  ~SyntaxError~ is raised at compile time if the given
          name does not exist in any enclosing function scope.


**** Module Namespace
     The namespace for a module is automatically created the first time a module
     is imported.

     - ~__main__~ :: The main module for a script is always called ~__main__~.

**** Class Definition Blocks • Arguments to exec and eval
     These are special in the context of name resolution.

     A class definition is an executable statement that may use and define
     names.  These references follow the normal rules for name resolution

     with an exception that /unbound local variables/ are looked up in the
     global namespace.

     The namespace of the class definition becomes the /attribute dictionary/
     of the class.

*** Builtins

*** Dynamic Feature Interaction

** Exceptions

* Syntax
  - Lexical analysis :: The lexical analyzer reads source code and creates a
       stream of tokens that are fed into the parser, which runs the program.
       This section describes how the lexical analyzer breaks a file's contents
       into tokens.

** Source Encoding---Unicode UTF-8
:CI:
#+CINDEX: Unicode
#+CINDEX: source encoding
#+CINDEX: UTF-8
:END:
   The lexical analyzer reads source code as Unicode code points; the source
   encoding, by default, is UTF-8.  The source file can give an encoding
   declaration on the first or second line, as:
   : # -*- coding: <encoding-name> -*-
   which must be a comment line that matches the regular expression:
   : coding[=:]\s*([-\w.]+)
   If an encoding is declared, the encoding name must be recognized by Python.

** Lines

*** Logical Lines
:CI:
#+CINDEX: logical line
:END:
    A Python program is divided into logical lines.  The end of logical line is
    represented by the token ~<NEWLINE>~.  A logical line is constructed from
    one or more physical lines by following the explicit or implicit line
    joining rules.

*** Physical Lines
:CI:
#+CINDEX: physical line
:END:
    A physical line is a sequence of characters terminated by an end-of-line
    sequence---the Unix form using ASCII ~LF~ (linefeed), the Windows form
    using the ASCII sequence ~CR LF~ (return followed by linefeed), or the old
    Macintosh form using the ASCII ~CR~ (return) character---or end of input.

*** Explicit Line Joining Rules
    Two or more physical lines may be joined into logical lines using backslash
    characters (~\~), according to the following rule:

    When a physical line ends in a backslash that is not part of a string
    literal or comment, it is joined with the following forming a single
    logical line, deleting the backslash and the following end-of-line
    character.

*** Implicit Line Joining Rules
    Expressions in parentheses, square brackets or curly braces can be split
    over more than one physical line without using backslashes.  Implicitly
    continued lines can carry comments.  The indentation of the continuation
    lines is not important.  Blank continuation lines are allowed.

#+BEGIN_EXPORT  texinfo
@tex
\bigskip\hrule height 1pt \relax\bigskip
@end tex
#+END_EXPORT
-----
#+BEGIN_EXAMPLE
month_names = [`Januari', `Februari', `Maart',      # These are the
               `April',   `Mei',      `Juni',       # Dutch names
               `Juli',    `Augustus', `September',  # for the months
               `Oktober', `November', `December']   # of the year
#+END_EXAMPLE
-----
#+BEGIN_EXPORT texinfo
@tex
\bigskip\hrule height 1pt\relax\bigskip
@end tex
#+END_EXPORT

*** Blank Lines
    + A logical line that contains only spaces, tabs, formfeeds and possibly a
      comment, is ignored (i.e., no NEWLINE token is generated).
*** Comments
    A comment starts with a hash character (#) that is not part of a string
    literal, and ends at the end of the physical line.  A comment signifies the
    end of the logical line unless the implicit line joining rules are invoked.
    A line ending in a backslash cannot carry a comment.  A backslash does not
    continue a comment.
*** Indentation
    Leading whitespace (spaces and tabs) at the beginning of a logical line is
    used to compute the indentation level of the line, which in turn is used to
    determine the grouping of statements.
**** Tabs
     Tabs are replaced by spaces to produce groups of eight.  The total number
     of spaces preceding the first non-blank character then determines the
     line’s indentation.
**** TabError
     Indentation is rejected as inconsistent if a source file mixes tabs and
     spaces in a way that makes the meaning dependent on the worth of a tab in
     spaces; a ~TabError~ is raised in that case.
**** Formfeed
     A formfeed character may be present at the start of the line; it will be
     ignored for the indentation calculations above. Formfeed characters
     occurring elsewhere in the leading whitespace have an undefined effect
**** ~INDENT~ and ~DEDENT~ Tokens
     The indentation levels of consecutive lines are used to generate ~INDENT~
     and ~DEDENT~ tokens, using a stack, as follows.
***** Zero
      Before the first line of the file is read, a single zero is pushed on the
      stack; this will never be popped off again.
***** Numbers Pushed On
      The numbers pushed on the stack will always be strictly increasing from
      bottom to top.  At the beginning of each logical line, the line’s
      indentation level is compared to the top of the stack. If it is equal,
      nothing happens. If it is larger, it is pushed on the stack, and one
      ~INDENT~ token is generated.
***** Numbers Pushed Off
      If it is smaller, it must be one of the numbers occurring on the stack;
      all numbers on the stack that are larger are popped off, and for each
      number popped off a ~DEDENT~ token is generated.
***** End Of File
      At the end of the file, a ~DEDENT~ token is generated for each number
      remaining on the stack that is larger than zero.
** Tokens
   - ~NEWLINE~
   - ~INDENT~
   - ~DEDENT~
   - ~IDENTIFIERS~
   - ~KEYWORDS~
   - ~LITERALS~
   - ~OPERATORS~
   - ~DELIMITERS~
*** Identifiers
    Also referred to as /names/.

    Within the ASCII range (U+0001..U+007F), the valid characters for
    identifiers are the same as in Python 2.x: the uppercase and lowercase
    letters A through Z, the underscore _ and, except for the first character,
    the digits 0 through 9.

    Python 3.0 introduces additional characters from outside the ASCII range
    (see [[https://www.python.org/dev/peps/pep-3131][PEP 3131]]).

    Identifiers are unlimited in length. Case is significant.
*** Keywords
    Also referred to as /reserved words/.

    Reserved words cannot be used as ordinary identifiers.
*** Reserved Classes of Identifiers
    Certain classes of identifiers (besides keywords) have special
    meanings. These classes are identified by the patterns of leading and
    trailing underscore characters:

    - ~_*~ :: These identifiers are not imported by the statement ~from module
              import *~.
    - ~__*__~ :: System-defined names.  These names are defined by the
                 interpreter and its implementation (including the standard
                 library).  Current system names are discussed in the [[https://docs.python.org/3/reference/datamodel.html#specialnames][Special
                 method names]] section and elsewhere.
    - ~__*~ :: Class-private names.  Names in this category, when used within
               the context of a class definition, are re-written to use a
               mangled form to help avoid name clashes between “private”
               attributes of base and derived classes.
** Literals
   Literals are notations for constant values of some built-in types.
*** Bytes Literals
    Whitespace is not allowed between the bytesprefix and the rest of the
    literal.  They can be enclosed in matching single quotes (') or double
    quotes ("). They can also be enclosed in matching groups of three single or
    double quotes.  The backslash (\) character is used to escape characters
    that otherwise have a special meaning, such as newline, backslash itself,
    or the quote character.

    Bytes literals are always prefixed with 'b' or 'B'; they produce an
    instance of the ~bytes~ type instead of the ~str~ type. They may only
    contain ASCII characters; bytes with a numeric value of 128 or greater must
    be expressed with escapes.
*** String Literals
    Whitespace is not allowed between the stringprefix and the rest of the
    literal.  They can be enclosed in matching single quotes (') or double
    quotes ("). They can also be enclosed in matching groups of three single or
    double quotes.  The backslash (\) character is used to escape characters
    that otherwise have a special meaning, such as newline, backslash itself,
    or the quote character.
*** Raw Strings
    Both string and bytes literals may optionally be prefixed with a letter 'r'
    or 'R'; such strings are called /raw strings/ and treat backslashes as
    literal characters.  As a result, in string literals, '\U' and '\u' escapes
    in raw strings are not treated specially.

    *New in version 3.3:* The 'rb' prefix of raw bytes literals has been added
    as a synonym of 'br'.
*** Formatted String Literals
    A string literal with 'f' or 'F' in its prefix is a formatted string
    literal; the 'f' may be combined with 'r', but not with 'b' or 'u',
    therefore raw formatted strings are possible, but formatted bytes literals
    are not.

    In triple-quoted literals, unescaped newlines and quotes are allowed (and
    are retained), except that three unescaped quotes in a row terminate the
    literal.

    Unless an 'r' or 'R' prefix is present, escape sequences in string and
    bytes literals are interpreted according to rules similar to those used by
    Standard C.
    - ~\newline~ :: ignored
    - ~\\~ :: backslash
    - ~\'~ :: single quote
    - \"~ :: double quote
    - ~\a~ :: ~BEL~
    - ~\b~ :: ~BS~
    - ~\f~ :: ~FF~
    - ~\n~ :: ~LF~
    - ~\r~ :: ~CR~
    - ~\t~ :: ~TAB~
    - ~\v~ :: ~VT~
    - ~\ooo~ :: char with octal value ~ooo~
    - ~\xhh~ :: char with hex value ~hh~

    Escape sequences only recognized in string literals are:
    - ~\N{name}~ :: Character named name in the Unicode database
    - ~\uxxxx~ :: char with 16-bit hex value ~xxxx~
    - ~\Uxxxxxxxx~ :: char with 32-bit hex value ~xxxxxxxx~
*** Unrecognized Escape Sequences
    All unrecognized escape sequences are left in the string unchanged, i.e.,
    the backslash is left in the result. (This behavior is useful when
    debugging: if an escape sequence is mistyped, the resulting output is more
    easily recognized as broken.) It is also important to note that the escape
    sequences only recognized in string literals fall into the category of
    unrecognized escapes for bytes literals.

    *Changed in version 3.6*: Unrecognized escape sequences produce a
    ~DeprecationWarning~. In some future version of Python they will be a
    ~SyntaxError~.
*** Raw Strings and Backslashes
    Even in a raw literal, quotes can be escaped with a backslash, but the
    backslash remains in the result;

    A raw literal cannot end in a single backslash (since the backslash would
    escape the following quote character).

    Note also that a single backslash followed by a newline is interpreted as
    those two characters as part of the literal, not as a line continuation.
*** Numeric Literals
    There are three types of numeric literals: integers, floating point
    numbers, and imaginary numbers.  Complex numbers can be formed by adding a
    real number and an imaginary number.  Note that numeric literals do not
    include a sign.  To create a negative literal, use the unary operator ~-~.
*** Integer Literals
    Integer literals are:
    - decimal integer :: 123_456_789
    - binary integer :: 0b0101 | 0B0101
    - octal integer :: 0o123 | 0O123
    - hex integer :: 0x10af | 0X10AF

    There is no limit for the length of integer literals apart from what can be
    stored in available memory.  Underscores can be used to group digits for
    readability, and are ignored for determining value.
*** Floating Point Literals
    The integer and exponent parts are always interpreted using radix 10.  The
    allowed range of floating point literals is implementation-dependent.
    Underscores are supported for digit grouping.
*** Imaginary Literals
    An imaginary literal is a floating point literal followed by the letter
    ~j|J~.  An imaginary literal yields a complex number with a real part of
    0.0.  Complex numbers are represented as a pair of floating point numbers.
    To create a complex number with a nonzero real part, add a floating point
    number to it, e.g., (~3+4j~).
*** Ellipsis Literals
    ~...~ :: A sequence of three periods has a special meaning as an ellipsis
    literal.

* Import System
  - module :: An *object* that serves as an organizational unit of Python code.
              Modules have a *namespace* containing arbitrary Python
              objects.  Modules are loaded into Python by the process of
              *importing*.
  - package :: A Python *module* which can contain submodules or recursively,
               subpackages.  Technically, a *package* is a Python *module* with
               an ~__path__~ attribute.


  One module gains access to code from another module by the process of
  /importing/ it.  There are several different mechanisms that can be used to
  import code.
  - ~import~ Statement :: combines a search for a named module using the
       ~__import__()~ function, then binds the results of that search, the
       return value of ~__import__()~, to a name in the local scope.
  - ~builtins.__import__()~ :: a direct call can be made to ~__import__()~,
       which will perform a search for a module; if a module is found, it
       creates the module.  No name-binding operation occurs, however.
  - ~importlib.import_module()~ :: may choose to bypass ~__import__()~ and use
       its own solutions to implement import semantics.


  - When a module is first imported, Python /searches/ for the module and if
    found, it /creates a module object/ (see ~types.ModuleType()~),
    initializing it.
  - If the named module cannot be found, a ~ModuleNotFoundError~ is raised.
  - Python implements various strategies to search for the named module when
    the import machinery is invoked.
  - These strategies can be modified and extended by using various /hooks/.

** ~importlib~ Module
   The [[https://docs.python.org/3/library/importlib.html#module-importlib][importlib module]] provides a rich API for interacting with the import
   system.

   The Standard Library ~importlib.import_module()~ provides a recommended,
   simpler API than built-in ~__import__()~ for invoking the import machinery.

** Packages
   Python has only one type of module object, and all modules are of this type.
   To help organize modules and provide a naming hierarchy, Python has a
   concept of *packages*.

   #+TEXINFO: @heading Packages and Modules Similar to File System
   #+LATEX: \subsection*{Packages and Modules Similar to File System}
   You can think of /packages/ as the directories on a file system and
   /modules/ as files within directories, but don’t take this analogy too
   literally since packages and modules need not originate from the file
   system.  Like file system directories, /packages/ are organized
   hierarchically, and /packages/ may themselves contain /subpackages/, as well
   as regular /modules/.
